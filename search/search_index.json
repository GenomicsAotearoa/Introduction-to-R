{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Introduction to R Lesson Overview 1. Introduction General overview of R 2. R Basics In the beginning.... 3. Data prelude What is data how it works 4. Factors and Dataframes  Handling Data 5. Data Visualisation Plotting 6. Producing reports with knitr Writing Reports 7. R-help More Resources Appendix Description Introduction to Bioconductor Bioinformatics Resources Data wrangling and analyses with Tidyverse The Tidyverse for handling data <p>Attribution notice</p> <ul> <li>The material used to prepare for this workshop was extracted from Intro to R and RStudio for Genomics maintained by Carpentries foundation  https://datacarpentry.org/genomics-r-intro/</li> </ul>"},{"location":"00-introduction/","title":"Introducing R and RStudio IDE","text":"<p>Learning outcomes</p> Key pointsObjectives <ul> <li>R is a powerful, popular open-source scripting language</li> <li>You can customize the layout of RStudio, and use the project feature   to manage the files and packages used in your analysis</li> <li>RStudio allows you to run R in an easy-to-use interface and makes it   easy to find help</li> </ul> <ul> <li>Know advantages of analyzing data in R</li> <li>Know advantages of using RStudio</li> <li>Create an RStudio project, and know the benefits of working within a    project</li> <li>Be able to customize the RStudio layout</li> <li>Be able to locate and change the current working directory with    <code>getwd()</code> and <code>setwd()</code></li> <li>Compose an R script file containing comments and commands</li> <li>Understand what an R function is</li> <li>Locate help for an R function using <code>?</code>, <code>??</code>, and <code>args()</code></li> </ul>"},{"location":"00-introduction/#getting-ready-to-use-r-for-the-first-time","title":"Getting ready to use R for the first time","text":"<p>In this lesson we will take you through the very first things you need to get R working.</p>"},{"location":"00-introduction/#a-brief-history-of-r","title":"A Brief History of R","text":"<p>R has been around since 1995, and was created by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand. R is based off the S programming language developed at Bell Labs and was developed to teach introductory statistics.  See this slide  deck  by Ross Ihaka for more info on the subject.</p>"},{"location":"00-introduction/#advantages-of-using-r","title":"Advantages of using R","text":"<p>At more than 20 years old, R is fairly mature and growing in popularity. However, programming isn't a popularity contest. Here are key advantages of analyzing data in R:</p> <ul> <li>R is open     source. This     means R is free - an advantage if you are at an institution where     you have to pay for your own      MATLAB or      SAS license. Open      source, is important to your colleagues in parts of the world where      expensive software in inaccessible. It also means that R is actively      developed by a community      (see r-project.org), and there are      regular updates.</li> <li>R is widely used. Ok, maybe programming is a popularity contest.     Because, R is used in many areas (not just bioinformatics), you are     more likely to find help online when you need it. Chances are,     almost any error message you run into, someone else has already     experienced.</li> <li>R is powerful. R runs on multiple platforms     (Windows/MacOS/Linux). It can work with much larger datasets than     popular spreadsheet programs like Microsoft Excel, and because of     its scripting capabilities is far more reproducible. Also, there are     thousands of available software packages for science, including genomics and other areas of life science.</li> </ul> <p>Discussion: Your experience</p> <p>What has motivated you to learn R? Have you had a research question for which spreadsheet programs such as Excel have proven difficult to use, or where the size of the data set created issues?</p>"},{"location":"00-introduction/#introducing-rstudio-server","title":"Introducing RStudio Server","text":"<p>In these lessons, we will be making use of a software called RStudio, an Integrated Development Environment (IDE). RStudio, like most IDEs, provides a graphical interface to R, making it more user-friendly, and providing dozens of useful features. We will introduce additional benefits of using RStudio as you cover the lessons. In this case, we are specifically using RStudio Server, a version of RStudio that can be accessed in your web browser. RStudio Server has the same features of the Desktop version of RStudio you could download as standalone software.</p> <p></p>"},{"location":"00-introduction/#overview-and-customization-of-the-rstudio-layout","title":"Overview and customization of the RStudio layout","text":"<p>Here are the major windows (or panes) of the RStudio environment:</p> <p></p> <ul> <li>Source: This pane is where you will write/view R scripts. Some     outputs (such as if you view a dataset using <code>View()</code>) will appear     as a tab here.</li> <li>Console/Terminal/Jobs: This is actually where you see the     execution of commands. This is the same display you would see if you     were using R at the command line without RStudio. You can work     interactively (i.e.\u00a0enter R commands here), but for the most part we     will run a script (or lines in a script) in the source pane and     watch their execution and output here. The \"Terminal\" tab give you     access to the BASH terminal (the Linux operating system, unrelated     to R). RStudio also allows you to run jobs (analyses) in the     background. This is useful if some analysis will take a while to     run. You can see the status of those jobs in the background.</li> <li>Environment/History: Here, RStudio will show you what datasets     and objects (variables) you have created and which are defined in     memory. You can also see some properties of objects/datasets such as     their type and dimensions. The \"History\" tab contains a history of     the R commands you've executed R.</li> <li>Files/Plots/Packages/Help/Viewer: This multi-purpose pane will     show you the contents of directories on your computer. You can also     use the \"Files\" tab to navigate and set the working directory. The     \"Plots\" tab will show the output of any plots generated. In     \"Packages\" you will see what packages are actively loaded, or you     can attach installed packages. \"Help\" will display help files for R     functions and packages. \"Viewer\" will allow you to view local web     content (e.g.\u00a0HTML outputs).</li> </ul> <p>Uploads and downloads in the cloud</p> <p>In the \"Files\" tab you can select a file and download it from your cloud instance (click the \"more\" button) to your local computer. Uploads are also possible.</p> <p>All of the panes in RStudio have configuration options. For example, you can minimize/maximize a pane, or by moving your mouse in the space between panes you can resize as needed. The most important customization options for pane layout are in the <code>View</code> menu. Other options such as font sizes, colors/themes, and more are in the <code>Tools</code> menu under <code>Global Options</code>.</p> <p>You are working with R</p> <p>Although we won't be working with R at the terminal, there are lots of reasons to. For example, once you have written an RScript, you can run it at any Linux or Windows terminal without the need to start up RStudio. We don't want you to get confused - RStudio runs R, but R is not RStudio. For more on running an R Script at the terminal see this Software Carpentry lesson.</p>"},{"location":"00-introduction/#create-an-rstudio-project","title":"Create an RStudio project","text":"<p>One of the first benefits we will take advantage of in RStudio is something called an RStudio Project. An RStudio project allows you to more easily:</p> <ul> <li>Save data, files, variables, packages, etc. related to a specific      analysis project</li> <li>Restart work where you left off</li> <li>Collaborate, especially if you are using version control such as     git</li> </ul> <ol> <li> <p>To create a project, go to the File menu, and click New Project</p> <p></p> </li> <li> <p>In the window that opens select Existing Directory     Then select Browse...      Choose and then click <code>~/R4Genomics</code>.</p> </li> <li> <p>Finally click Create Project. In the     \"Files\" tab of your output pane (more about the RStudio layout above),      you should see an RStudio project file, <code>R4Genomics.Rproj</code>. All      RStudio projects end with the <code>.Rproj</code> file extension.</p> </li> </ol> <p>Make your project more reproducible with renv</p> <p>One of the most wonderful and also frustrating aspects of working with R is managing packages. We will talk more about them, but packages (e.g.\u00a0<code>ggplot2</code>) are add-ons that extend what you can do with R. Unfortunately it is very common that you may run into versions of R and/or R packages that are not compatible. This may make it difficult for someone to run your R script using their version of R or a given R package, and/or make it more difficult to run their scripts on your machine. renv is an RStudio add-on that will associate your packages and project so that your work is more portable and reproducible. To turn on renv click on the Tools menu and select Project Options. Under Enviornments check off \"Use renv with this project\" and follow any installation instructions.</p>"},{"location":"00-introduction/#creating-your-first-r-script","title":"Creating your first R script","text":"<p>Now that we are ready to start exploring R, we will want to keep a record of the commands we are using. To do this we can create an R script:</p> <ol> <li>Click the File menu and select New File and then R Script. </li> <li>Before we go any further, save your script by clicking the save/disk icon     that is in the bar above the first line in the script editor, or click the     File menu and select Save. </li> <li>In the Save File window that opens, name your file <code>genomics_r_basics</code>.     The new script <code>genomics_r_basics.R</code> should appear under Files in the     output pane. By convention, R scripts end with the file extension <code>.R</code>.</li> </ol>"},{"location":"00-introduction/#getting-to-work-with-r-navigating-directories","title":"Getting to work with R: Navigating directories","text":"<p>Now that we have covered the more aesthetic aspects of RStudio, we can get to work using some commands. We will write, execute, and save the commands we learn in our <code>genomics_r_basics.R</code> script that is loaded in the Source pane. First, lets see what directory we are in. To do so, type the following command into the script:</p> <p>R-project</p> <pre><code>getwd()\n</code></pre> <p>To execute this command, make sure your cursor is on the same line the command is written. Then click the <code>Run</code> button that is just above the first line of your script in the header of the Source pane.</p> <p>In the console, we expect to see the following output:</p> <p>Output</p> <pre><code>[1] \"/home/shared/&lt;USERID&gt;\"\n</code></pre> <ul> <li>Notice, at the Console, the instruction you executed above the output in blue.</li> </ul> <p>Since we will be learning several commands, we may already want to keep some short notes in our script to explain the purpose of the command. Entering a <code>#</code> before any line in an R script turns that line into a comment, which R will not try to interpret as code. Edit your script to include a comment on the purpose of commands you are learning, e.g.:</p> <p>R-project</p> <pre><code># this command shows the current working directory getwd()\n</code></pre> <p>Exercise : Work interactively in R</p> <p>What happens when you try to enter the <code>getwd()</code> command in the Console  pane?</p> Solution <p>You will get the same output you did as when you ran <code>getwd()</code> from the source. You can run any command in the Console, however, executing it from the source script will make it easier for us to record what we have done, and ultimately run an entire script, instead of entering commands one-by-one.</p> <p>For the purposes of this exercise we want you to be in the directory <code>\"/home/shared/&lt;USERID&gt;/R4Genomics\"</code>. What if you weren't? You can set your home directory using the <code>setwd()</code> command. Enter this command in your script, but don't run this yet.</p> <p>R-project</p> <pre><code># This sets the working directory\nsetwd()\n</code></pre> <p>You may have guessed, you need to tell the <code>setwd()</code> command what directory you  want to set as your working directory. To do so, inside of the parentheses, open a set of quotes <code>\"\"</code>. Inside the quotes enter a <code>/</code> which is the root directory for  Linux. Next, use the <code>Tab</code> key, to take advantage of RStudio's  tab-autocompletion method, to select <code>home</code>, <code>shared</code>, your <code>&lt;USERID&gt;</code> and  <code>R4Genomics</code> directory. The path in your script should look like this:</p> <p>R-project</p> <pre><code># This sets the working directory \nsetwd(\"/home/shared/&lt;USERID&gt;/R4Genomics\")\n</code></pre> <p>When you run this command, the console repeats the command, but gives you no output. Instead, you see the blank R prompt: <code>&gt;</code>. Congratulations! Although it seems small, knowing what your working directory is and being able to set your working directory is the first step to analyzing your data.</p> <p>Never use <code>setwd()</code></p> <p>Wait, what was the last 2 minutes about? Well, setting your working directory is something you need to do, you need to be very careful about using this as a step in your script. For example, what if your script is being on a computer that has a different directory structure? The top-level path in a Unix file system is root <code>/</code>, but on Windows it is likely <code>C:\\</code>. This is one of several ways you might cause a script to break because a file path is configured differently than your script anticipates. R packages like <code>here</code> and the function <code>file.path()</code> allow you to specify file paths that are operating system independent. See  Jenny Bryan's blog post for this and other R tips.</p>"},{"location":"00-introduction/#using-functions-in-r-without-needing-to-master-them","title":"Using functions in R, without needing to master them","text":"<p>A function in R (or any computing language) is a short program that takes some input and returns some output. Functions may seem like an advanced topic (and they are), but you have already used at least one function in R. <code>getwd()</code> is a function! The next sections will help you understand what is happening in any R script.</p> <p>Exercise: What do these functions do?</p> <p>Try the following functions by writing them in your script. See if you can guess what they do, and make sure to add comments to your script about your assumed purpose. </p> <ul> <li><code>dir()</code></li> <li><code>sessionInfo()</code></li> <li><code>date()</code></li> <li><code>Sys.time()</code></li> <li><code>.libPaths()</code></li> </ul> Solution <ul> <li><code>dir()</code> lists files in the working directory</li> <li><code>sessionInfo()</code> gives the version of R and additional info     including on attached packages</li> <li><code>date()</code> gives the current date</li> <li><code>Sys.time()</code> gives the current time</li> <li><code>.libPaths()</code> shows what libraries are available</li> </ul> <p>Notice: Commands are case sensitive! </p> <p>You have hopefully noticed a pattern: an R function has three key properties:</p> <ul> <li>Functions have a name (e.g.\u00a0<code>dir</code>, <code>getwd</code>); note that functions are case    sensitive!</li> <li>Following the name, functions have a pair of <code>()</code></li> <li>Inside the parentheses, a function may take 0 or more arguments</li> </ul> <p>An argument may be a specific input for your function and/or may modify the function's behavior. For example the function <code>round()</code> will round a number with a decimal:</p> <p>r</p> <pre><code># This will round a number to the nearest integer\nround(3.14)\n</code></pre> Output <pre><code>[1] 3\n</code></pre>"},{"location":"00-introduction/#getting-help-with-function-arguments","title":"Getting help with function arguments","text":"<p>What if you wanted to round to one significant digit? <code>round()</code> can do this, but you may first need to read the help to find out how. To see the help (in R sometimes also called a \"vignette\") enter a <code>?</code> in front of the function name:</p> <p>r</p> <pre><code>?round()\n</code></pre> <p>The \"Help\" tab will show you information (often, too much information). You will slowly learn how to read and make sense of help files. Checking the \"Usage\" or \"Examples\" headings is often a good place to look first. If you look under \"Arguments,\" we also see what arguments we can pass to this function to modify its behavior. You can also see a function's argument using the <code>args()</code> function:</p> <p>r</p> <pre><code>args(round)\n</code></pre> <p>Output</p> <pre><code>function (x, digits = 0) \nNULL\n</code></pre> <p><code>round()</code> takes two arguments, <code>x</code>, which is the number to be rounded, and a <code>digits</code> argument. The <code>=</code> sign indicates that a default (in this case 0) is already set. Since <code>x</code> is not set, <code>round()</code> requires we provide it, in contrast to <code>digits</code> where R will use the default value 0 unless you explicitly provide a different value. We can explicitly set the digits argument when we call the function:</p> <p>r</p> <pre><code>round(3.14159, digits = 2)\n</code></pre> <p>Output</p> <pre><code>[1] 3.14\n</code></pre> <p>Or, R accepts what we call \"positional arguments\", if you pass a function arguments separated by commas, R assumes that they are in the order you saw when we used <code>args()</code>. In the case below that means that <code>x</code> is 3.14159 and digits is 2.</p> <p>r</p> <pre><code>round(3.14159, 2)\n</code></pre> <p>Finally, what if you are using <code>?</code> to get help for a function in a package not installed on your system, such as when you are running a script which has dependencies.</p> <p>r</p> <pre><code>?geom_point()\n</code></pre> <p>The above will return an error:</p> <p>Error</p> <pre><code>Error in .helpForCall(topicExpr, parent.frame()) :\n   no methods for \u2018geom_point\u2019 and no documentation for it as a function\n</code></pre> <p>Use two question marks (i.e.\u00a0<code>??geom_point()</code>) and R will return results from a search of the documentation for packages you have installed on your computer in the \"Help\" tab. Finally, if you think there should be a function, for example a statistical test, but you aren't sure what it is called in R, or what functions may be available, use the <code>help.search()</code> function.</p> <p>Exercise: Searching for R functions</p> <p>Use <code>help.search()</code> to find R functions for the following statistical functions. Remember to put your search query in quotes inside the function's parentheses.</p> <ul> <li>Chi-Squared test</li> <li>Student t-test</li> <li>Mixed linear model</li> </ul> Success <p>While your search results may return several tests, we list a few you might find: </p> <ul> <li>Chi-Squared test: <code>stats::Chisquare</code> </li> <li>Student t-test: <code>stats::t.test</code> </li> <li>Mixed linear model: <code>stats::lm.glm</code></li> </ul> <p>We will discuss more on where to look for the libraries and packages that contain functions you want to use. For now, be aware that two important ones are: </p> <ul> <li>CRAN, the main repository for R</li> <li>Bioconductor, a popular repository for    bioinformatics-related R packages.</li> </ul>"},{"location":"00-introduction/#rstudio-contextual-help","title":"RStudio contextual help","text":"<p>Here is one last bonus we will mention about RStudio. It's difficult to remember all of the arguments and definitions associated with a given function. When you start typing the name of a function and hit the Tab key, RStudio will display functions and associated help:</p> <p></p> <p>Once you type a function, hitting the Tab inside the parentheses will show you the function's arguments and provide additional help for each of these  arguments.</p> <p></p>"},{"location":"01-r-basics/","title":"R Basics","text":"<p>Learning objectives</p> Key pointsObjectivesQuestions <ul> <li>Effectively using R is a journey of months or years. Still, you don't have to be an expert to use R, and you can start using and analyzing your data with about a day's worth of training.</li> <li>It is important to understand how R organizes data in a given object type and how the mode of that type (e.g. numeric, character, logical, etc.) will determine how R will operate on that data.</li> <li>Working with vectors effectively prepares you to understand how R organizes data.</li> </ul> <ul> <li>Be able to create the most common R objects, such as vectors</li> <li>Understand that vectors have modes, which correspond to the type of data they contain</li> <li>Be able to use arithmetic operators on R objects</li> <li>Be able to retrieve (subset), name, or replace values from a vector</li> <li>Be able to use logical operators in a subsetting operation</li> <li>Understand that lists can hold data of more than one mode and can be indexed</li> </ul> <ul> <li>What will these lessons not cover?</li> <li>What are the basic features of the R language?</li> <li>What are the most common objects in R?</li> </ul>"},{"location":"01-r-basics/#the-fantastic-world-of-r-awaits-you-or-nobody-wants-to-learn-how-to-use-r","title":"\"The fantastic world of R awaits you\" OR \"Nobody wants to learn how to use R\"","text":"<p>Before we begin this lesson, we want you to be clear on the goal of the workshop and these lessons. We believe that every learner can achieve competency with R. You have reached competency when you find that you are able to use R to handle common analysis challenges in a reasonable amount of time (which includes the time needed to look at learning materials, search for answers online, and ask colleagues for help). As you spend more time using R (there is no substitute for regular use and practice), you will gain competency and expertise. The more familiar you get, the more complex the analyses you will be able to carry out, with less frustration and in less time - the fantastic world of R awaits you!</p>"},{"location":"01-r-basics/#what-these-lessons-will-not-teach-you","title":"What these lessons will not teach you","text":"<p>Nobody wants to learn how to use R. People want to learn how to use R to analyze their own research questions! Ok, maybe some folks learn R for R's sake, but these lessons assume that you want to start analyzing genomic data as soon as possible. Given this, there are many valuable pieces of information about R that we simply won't have time to cover. Hopefully, we will clear the hurdle of giving you just enough knowledge to be dangerous, which can be a high bar in R! We suggest you look into the additional learning materials in the tip box below.</p> <p>Here are some R skills we will not cover in these lessons</p> <ul> <li>How to create and work with R matrices</li> <li>How to create and work with loops and conditional statements, and   the \"apply\" family of functions (which are super useful, read more   here)</li> <li>How to do basic string manipulations (e.g.\u00a0finding patterns in text   using <code>grep()</code>, and replacing text using <code>gsub()</code>)</li> <li>How to plot using the default R graphic tools (we will cover plot   creation, but will do so using the popular plotting package   <code>ggplot2</code>)</li> <li>How to use advanced R statistical functions</li> </ul> <p>Where to learn more</p> <p>The following are good resources for learning more about R. Some of them can be quite technical, but if you are a regular R user you may ultimately need this technical knowledge.</p> <ul> <li>R for Beginners: By Emmanuel Paradis and a great starting point </li> <li>The R Manuals: Maintained by the R project </li> <li>R contributed documentation: Also linked to the R project; importantly there are materials available in several languages </li> <li>R for Data Science: A wonderful collection by noted R educators and developers Garrett Grolemund and Hadley Wickham </li> <li>Practical Data Science for Stats: Not exclusively about R usage, but a nice collection of pre-prints on data science and applications for R </li> <li>Programming in R Software Carpentry lesson: There are several Software Carpentry lessons in R to choose from </li> </ul>"},{"location":"01-r-basics/#objects","title":"Objects","text":""},{"location":"01-r-basics/#creating-objects-in-r","title":"Creating objects in R","text":"<p>Reminder</p> <p>At this point you should be coding along in the <code>genomics_r_basics.R</code> script we created in the last episode. Writing your commands in the script (and commenting it) will make it easier to record what you did and why. </p> <p>What might be called a variable in many languages is called an object in R.</p> <p>To create an object, you need:</p> <ul> <li>A name (e.g.\u00a0<code>a</code>)</li> <li>A value (e.g.\u00a0<code>1</code>)</li> <li>The assignment operator (<code>&lt;-</code>)</li> </ul> <p>In your script, <code>genomics_r_basics.R</code>, use the R assignment operator <code>&lt;-</code> to assign <code>1</code> to the object <code>a</code> as shown. Remember to leave a comment in the line above (using the <code>#</code>) to explain what you are doing:</p> <p>r</p> <pre><code># This line creates the object 'a' and assigns it the value '1'\n\na &lt;- 1\n</code></pre> <p>Next, run this line of code in your script. You can run a line of code by hitting the <code>Run</code> button that is above the first line of your script in the header of the 'Source' pane or you can use the appropriate shortcut:</p> <ul> <li>Windows execution shortcut: Ctrl + Enter</li> <li>Mac execution shortcut: Cmd(\u2318) + Enter</li> </ul> <p>To run multiple lines of code, highlight all the line you wish to run and then hit Run or use the shortcut key combo listed above. In the RStudio 'Console', you should see:</p> <pre><code>a &lt;- 1\n&gt;\n</code></pre> <p>The 'Console' will display lines of code run from a script and any outputs or status/warning/error messages (usually in red). In the 'Environment' window you will also get a table:</p> Values a 1 <p>The 'Environment' window allows you to keep track of the objects you have created in R.</p> <p>Exercise: Create some objects in R</p> <p>Create the following objects and give each object an appropriate name (your best guess at what name to use is fine):</p> <ol> <li>Create an object that has the value of number of pairs of human chromosomes</li> <li>Create an object that has a value of your favorite gene name</li> <li>Create an object that has this URL as its value: \"ftp://ftp.ensemblgenomes.org/pub/bacteria/release-39/fasta/bacteria_5_collection/escherichia_coli_b_str_rel606/\"</li> <li>Create an object that has the value of the number of chromosomes in a diploid human cell</li> </ol> Solution <p>Here as some possible answers to the challenge:</p> <pre><code>human_chr_number &lt;- 23\ngene_name &lt;- 'pten'\nensemble_url &lt;- \"ftp://ftp.ensemblgenomes.org/pub/bacteria/release-39/fasta/bacteria_5_collection/escherichia_coli_b_str_rel606/\"\nhuman_diploid_chr_num &lt;-  2 * human_chr_number\n</code></pre>"},{"location":"01-r-basics/#naming-objects-in-r","title":"Naming objects in R","text":"<p>Here are some important details about naming objects in R</p> <ul> <li>Avoid spaces and special characters   Object names cannot contain spaces or the minus sign (<code>-</code>). You can use    <code>_</code> to make names more readable. You should avoid using special characters   in your object name (e.g. <code>!</code> <code>@</code> <code>#</code> <code>.</code> <code>,</code> etc.). Also, object names    cannot begin with a number.</li> <li>Use short, easy-to-understand names   Avoid naming your objects using single letters (e.g. <code>n</code>, <code>p</code>,    etc.). This is mostly to encourage you to use names that would make sense to    anyone reading your code (a colleague, or even yourself a year from now).    Also, avoiding excessively long names will make your code more readable.</li> <li>Avoid commonly used names   Several names may already have a definition in the R language    (e.g. <code>mean</code>, <code>min</code>, <code>max</code>). One clue that a name already has meaning is that    if you start typing a name in RStudio and it gets a colored highlight or    RStudio gives you a suggested autocompletion, you have chosen a name that has    a reserved meaning.</li> <li>Use the recommended assignment operator   In R, we use <code>&lt;-</code> as the preferred assignment operator. <code>=</code> works too, but is    most commonly used in passing arguments to functions (more on functions    later). Shortcuts for the R assignment operator are:<ul> <li>Windows execution shortcut: Alt + -</li> <li>Mac execution shortcut: Option + -</li> </ul> </li> </ul> <p>There are a few more suggestions about naming and style you can learn more about as you write more R code. Several \"style guides\" have advice, and one to start with is the tidyverse R  style guide.</p> <p>Pay attention to warnings in the 'Source' panel</p> <p>If you enter a line of code in your script that contains an error, RStudio may give you an error message and underline this mistake. Sometimes, these messages are easy to understand, but often, the messages may need some figuring out. Paying attention to these warnings will help you avoid mistakes. In the example below, our object name has a space, which is not allowed in R. The error message does not say this directly, but R is \"not sure\" about how to assign the number to <code>human_ chr_number</code> when the object name we want is <code>human_chr_number</code></p> <p></p>"},{"location":"01-r-basics/#reassigning-object-names-or-deleting-objects","title":"Reassigning object names or deleting objects","text":"<p>Once an object has a value, you can change that value by overwriting it. R will not give you a warning or error if you overwrite an object, which may or may not be a good thing depending on how you look at it.</p> <p>r</p> <pre><code># gene_name has the value 'pten' or whatever value you used in the challenge\n# We will now assign the new value 'tp53'\n\ngene_name &lt;- 'tp53'\n</code></pre> <p>You can also remove an object from R's memory entirely. The <code>rm()</code> function will delete the object.</p> <p>r</p> <pre><code># Delete the object 'gene_name'\nrm(gene_name)\n</code></pre> <p>If you run a line of code that has only an object name, R will normally display the contents of that object. In this case, we are told the object no longer exists.</p> <p>r</p> <pre><code>gene_name\n</code></pre> <p>Error</p> <pre><code>Error: object 'gene_name' not found\n</code></pre>"},{"location":"01-r-basics/#understanding-object-data-types-modes","title":"Understanding object data types (modes)","text":"<p>In R, every object has two properties:</p> <ul> <li>Length: The number of distinct values are held in that object</li> <li>Mode: The classification (type) of that object</li> </ul> <p>We will get to the \"length\" property later in the lesson. The \"mode\"  property corresponds to the type of data an object represents. The most common modes you will encounter in R are:</p> Mode (abbreviation) Type of data Numeric (<code>num</code>) Numbers such as floating point (i.e. decimals, e.g. 1.0, 0.5, 3.14).  There are also more specific numeric types (<code>dbl</code> - Double, <code>int</code> - Integer). These differences are not relevant for most beginners and pertain to how these value are stored in memory Character (<code>chr</code>) A sequence of letters/numbers in single <code>''</code> or double <code>\"\"</code> quotes Logical (<code>logi</code>) Boolean values <code>TRUE</code> or <code>FALSE</code> <p>There are a few other modes (i.e.\u00a0\"complex\", \"raw\" etc.) but these are the three we will work with in this lesson.</p> <p>Data types are common across many programming languages, but also in natural language, where we refer to them as the parts of speech, e.g.\u00a0nouns, verbs, adverbs, etc. Once you know if a word - perhaps an unfamiliar one - is a noun, you can probably guess you can count it and make it plural if there is more than one (e.g.\u00a01 Tuatara, or 2 Tuataras). If something is an adjective, you can usually change it into an adverb by adding \"-ly\" (e.g.,\u00a0jejune vs. jejunely). Depending on the context, you may need to decide if a word is in one category or another (e.g \"cut\" may be (1) a noun when it's on your finger or (2) a verb when you are preparing vegetables). These concepts have important analogies when working with R objects.</p> <p>Exercise: Create objects and check their modes</p> <p>Create the following objects in R, then verify their modes using the <code>mode()</code> function. Try to guess what the mode will be before you look at the solution.</p> <ol> <li><code>chromosome_name &lt;- 'chr02'</code></li> <li><code>od_600_value &lt;- 0.47</code></li> <li><code>chr_position &lt;- '1001701'</code></li> <li><code>spock &lt;- TRUE</code></li> <li><code>pilot &lt;- Earhart</code></li> </ol> Solution <pre><code>mode(chromosome_name) \nmode(od_600_value) \nmode(chr_position) \nmode(spock) \nmode(pilot)\n</code></pre> <pre><code>[1] \"character\"\n[1] \"numeric\"\n[1] \"character\"\n[1] \"logical\"\nError: object 'pilot' not found\n</code></pre> <p>Notice from the solution that even if a series of numbers is given as a value R will consider them to be in the \"character\" mode if they are enclosed with single or double quotes. Also, notice that you cannot take a string of alphanumeric characters (i.e.,\u00a0Earhart) and assign it as a value for an object. In this case, R looks for an object named <code>Earhart</code>, but since there is no object, no assignment can be made. If <code>Earhart</code> did exist, then the mode of <code>pilot</code> would be whatever the mode of <code>Earhart</code> was originally. If we want to create an object called <code>pilot</code> that was the name \"Earhart\", we need to enclose <code>Earhart</code> in quotation marks.</p> <p>r</p> <pre><code>pilot &lt;- \"Earhart\"\nmode(pilot)\n</code></pre>"},{"location":"01-r-basics/#mathematical-and-functional-operations-on-objects","title":"Mathematical and functional operations on objects","text":"<p>Once an object exists (which, by definition, also means it has a mode), R can manipulate that object using appropriate methods. For example, objects of the numeric modes can be added, multiplied, divided, etc. R provides several mathematical (arithmetic) operators including:</p> Operator Description <code>+</code> Addition <code>-</code> Subtraction <code>*</code> Multiplication <code>/</code> Division <code>^</code> or <code>**</code> Exponentiation <code>%/%</code> Integer division (division where the remainder is discarded) <code>%%</code> Modulus (returns the remainder after division) <p>These can be used with literal numbers:</p> <p>r</p> <pre><code>(1 + (5 ** 0.5))/2\n</code></pre> <p>and importantly, can be used on any object that evaluates to (i.e.\u00a0interpreted by R) a numeric object:</p> <p>r</p> <pre><code>human_chr_number &lt;- 23\n\n# Multiply the object 'human_chr_number' by 2\nhuman_chr_number * 2\n</code></pre> <p>Exercise: Compute the golden ratio</p> <p>One approximation of the golden ratio (\\(\\phi\\)) can be found by taking the sum of  1 and the square root of 5, and dividing by 2 as in the example above.</p> \\[ \\phi = \\frac{1 + \\sqrt{5}}{2} \\] <p>Compute the golden ratio to 3 digits of precision using the <code>sqrt()</code> and <code>round()</code> functions. </p> <p>Hint: Remember the <code>round()</code> function can take two arguments.</p> Solution <pre><code>round((1 + sqrt(5))/2, digits = 3)\n\n# Notice that you can place one function inside of another.\n</code></pre>"},{"location":"01-r-basics/#vectors","title":"Vectors","text":"<p>Vectors are probably the most commonly used object type in R. A vector is a collection of values that are all of the same type (numbers, characters, etc.). One of the most common ways to create a vector is to use the <code>c()</code> function \u2014 the \"concatenate\" or \"combine\" function. Inside the function you may enter one or more values; for multiple values, separate each value with a comma:</p> <p>r</p> <pre><code># Create the SNP gene name vector\nsnp_genes &lt;- c(\"OXTR\", \"ACTN3\", \"AR\", \"OPRM1\")\n</code></pre> <p>Vectors always have a mode and a length. You can check these with the <code>mode()</code> and <code>length()</code> functions respectively. Another useful function that gives both of these pieces of information is the <code>str()</code> (structure) function.</p> <p>r</p> <pre><code># Check the mode, length, and structure of 'snp_genes' \nmode(snp_genes) \nlength(snp_genes) \nstr(snp_genes)\n</code></pre> <p>Vectors are very important in R. Another data type that we will work with later in this lesson, data frames, are collections of vectors. What we learn here about vectors will pay off even more when we start working with data frames.</p>"},{"location":"01-r-basics/#creating-and-subsetting-vectors","title":"Creating and subsetting vectors","text":"<p>Let's create a few more vectors to play around with:</p> <p>r</p> <pre><code># Some interesting human SNPs\n# While accuracy is important, typos in the data won't hurt you here\n\nsnps &lt;- c(\"rs53576\", \"rs1815739\", \"rs6152\", \"rs1799971\")\nsnp_chromosomes &lt;- c(\"3\", \"11\", \"X\", \"6\") \nsnp_positions &lt;- c(8762685, 66560624, 67545785, 154039662)\n</code></pre> <p>Once we have vectors, one thing we may want to do is retrieve one or more values from our vector. To do so, we use bracket notation. We type the name of the vector followed by square brackets. In those square brackets we place the index (i.e., a number that corresponds to the position of the value in the vector) in that bracket as follows:</p> <p>r</p> <pre><code># Get the 3rd value in the 'snps' vector\nsnps[3]\n</code></pre> <p>In R, every item in your vector is indexed, starting from the first item (1) through to the final number of items in your vector. You can also retrieve a range of numbers:</p> <p>r</p> <pre><code># Get the 1st to 3rd value in the 'snps' vector\n\nsnps[1:3]\n</code></pre> <p>If you want to retrieve several (but not necessarily sequential) items from a vector, you pass a vector of indices (i.e., a vector that has the numbered positions of the elements you wish to retrieve).</p> <p>r</p> <pre><code># Get the 1st, 3rd, and 4th value in the 'snps' vector\n\nsnps[c(1, 3, 4)]\n</code></pre> <p>There are additional (and perhaps less commonly used) ways of subsetting a vector (see these examples). Several of these subsetting expressions can be combined:</p> <p>r</p> <pre><code># Get the 1st through the 3rd value, and 4th value in the 'snps' vector\n# Yes, this is a little silly in a vector of only 4 values.\n\nsnps[c(1:3, 4)]\n</code></pre>"},{"location":"01-r-basics/#adding-to-removing-or-replacing-values-in-existing-vectors","title":"Adding to, removing, or replacing values in existing vectors","text":"<p>Once you have an existing vector, you may want to add a new item to it. To do so, you can use the <code>c()</code> function again to add your new value:</p> <p>r</p> <pre><code># Add the gene \"CYP1A1\" and \"APOA5\" to our 'snp_genes' vector\n# Note: This overwrites our existing vector.\n\nsnp_genes &lt;- c(snp_genes, \"CYP1A1\", \"APOA5\")\n</code></pre> <p>We can verify that \"snp_genes\" contains the new gene entry</p> <p>r</p> <pre><code>snp_genes\n</code></pre> Output <pre><code>[1] \"OXTR\"   \"ACTN3\"  \"AR\"     \"OPRM1\"  \"CYP1A1\" \"APOA5\" \n</code></pre> <p>Using a negative index will return a version of a vector with that index's value removed:</p> <p>r</p> <pre><code>snp_genes[-6]\n</code></pre> Output <pre><code>[1] \"OXTR\"   \"ACTN3\"  \"AR\"     \"OPRM1\"  \"CYP1A1\"\n</code></pre> <p>We can remove that value from our vector by overwriting it with this expression:</p> <p>r</p> <pre><code>snp_genes &lt;- snp_genes[-6]\n\nsnp_genes\n</code></pre> Output <pre><code>[1] \"OXTR\"   \"ACTN3\"  \"AR\"     \"OPRM1\"  \"CYP1A1\"\n</code></pre> <p>We can also explicitly rename or add a value to our index using bracket notation:</p> <p>r</p> <pre><code>snp_genes[7] &lt;- \"APOA5\"\n\nsnp_genes\n</code></pre> Output <pre><code>[1] \"OXTR\"   \"ACTN3\"  \"AR\"     \"OPRM1\"  \"CYP1A1\" NA       \"APOA5\" \n</code></pre> <p>Filling in the blanks</p> <p>Notice in the example above that there is an <code>NA</code> in the 6<sup>th</sup> position of the vector? Recall that R keeps track of every element in vectors by numeric indexing. This means that when we added a 7<sup>th</sup> element where there is no 6<sup>th</sup> element, R fills it with <code>NA</code> which functionally means \"missing value\" or \"Not Available\".</p> <p>Exercise: Examining and subsetting vectors</p> <p>Answer the following question to test your knowledge of vectors</p> <p>Which of the following are true of vectors in R?</p> <p>A) All vectors have a mode or a length  B) All vectors have a mode and a length  C) Vectors may have different lengths  D) Items within a vector may be of different modes  E) You can use the <code>c()</code> to add one or more items to an existing vector  F) You can use the <code>c()</code> to add a vector to an exiting vector</p> Solution <p>A) False - Vectors have both of these properties  B) True  C) True  D) False - Vectors have only one mode (e.g. numeric, character);     all items in a vector must be of this mode.  E) True  F) True</p>"},{"location":"01-r-basics/#logical-subsetting","title":"Logical subsetting","text":"<p>There is one last set of cool subsetting capabilities we want to introduce. It is possible within R to retrieve items in a vector based on a logical evaluation or numerical comparison. For example, let's say we wanted get all of the SNPs in our vector of SNP positions that were greater than 100,000,000. We could index using the <code>&gt;</code> (greater than) logical operator:</p> <p>r</p> <pre><code>snp_positions[snp_positions &gt; 100000000]\n</code></pre> Output <pre><code>[1] 154039662\n</code></pre> <p>In the square brackets you place the name of the vector followed by the comparison operator and (in this case) a numeric value. Some common logical operators in R are:</p> Operator Description <code>&lt;</code> Less than <code>&lt;=</code> Less than or equal to <code>&gt;</code> Greater than <code>&gt;=</code> Greater than or equal to <code>==</code> Exactly equal to <code>!=</code> Not equal to <code>!x</code> Not x <code>a | b</code> a or b <code>a &amp; b</code> a and b <p> The magic of programming</p> <p>The reason why the expression <code>snp_positions[snp_positions &gt; 100000000]</code> works  can be better understood if you examine what the expression  <code>snp_positions &gt; 100000000</code> evaluates to:</p> <p>r</p> <pre><code>snp_positions &gt; 100000000\n</code></pre> Output <pre><code>[1] FALSE FALSE FALSE  TRUE\n</code></pre> <p>The output above is a logical vector where the 4<sup>th</sup> element is <code>TRUE</code>. When you pass a logical vector as an index, R will return values that are or evaluate to <code>TRUE</code>:</p> <p>r</p> <pre><code>snp_positions[c(FALSE, FALSE, FALSE, TRUE)]\n</code></pre> Output <pre><code>[1] 154039662\n</code></pre> <p>If you have never coded before, this type of situation starts to expose the  \u201cmagic\u201d of programming. We mentioned before that in the bracket notation you  take your named vector followed by brackets which contain an index:  <code>named_vector[index]</code>. The \u201cmagic\u201d is that the index needs to evaluate to a  number. So, even if it does not appear to be an integer (e.g. 1, 2, 3),  as long as R can evaluate it, we will get a result. That our expression  <code>snp_positions[snp_positions &gt; 100000000]</code> evaluates to a number can be seen in  the following situation. If you wanted to know which index (1, 2, 3, or 4)  in our vector of SNP positions was the one that was greater than 100,000,000? We can use the <code>which()</code> function to return the indices of any item that  evaluates as <code>TRUE</code> in our comparison:</p> <p>r</p> <pre><code>which(snp_positions &gt; 100000000)\n</code></pre> Output <pre><code>[1] 4\n</code></pre> <p>Why this is important</p> <p>Often in programming we will not know what inputs and values will be used when  our code is executed. Rather than put in a pre-determined value (e.g 100000000)  we can use an object that can take on whatever value we need. So for example:</p> <p>r</p> <pre><code>snp_marker_cutoff &lt;- 100000000\nsnp_positions[snp_positions &gt; snp_marker_cutoff]\n</code></pre> Output <pre><code>[1] 154039662\n</code></pre> <p>Ultimately, it\u2019s putting together flexible, reusable code like this that gets at the \u201cmagic\u201d of programming!</p>"},{"location":"01-r-basics/#a-few-final-vector-tricks","title":"A few final vector tricks","text":"<p>Finally, there are a few other common retrieve or replace operations you may want to know about. First, you can check to see if any of the values of your vector are missing (i.e.\u00a0are <code>NA</code>, that stands for \"Not Available\"). Missing data will get a more detailed treatment later, but the <code>is.na()</code> function will return a logical vector, with <code>TRUE</code> for any <code>NA</code> value:</p> <p>r</p> <pre><code># Current value of 'snp_genes' inspected using 'str()':\n# chr [1:7] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\" \"CYP1A1\" NA \"APOA5\"\n\nis.na(snp_genes)\n</code></pre> Output <pre><code>[1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n</code></pre> <p>Sometimes, you may wish to find out if a specific value (or several values) is  present in a vector. You can do this using the comparison operator <code>%in%</code> which will return <code>TRUE</code> for any value in the vector you are searching:</p> <p>r</p> <pre><code># Current value of 'snp_genes' inspected using 'str()':\n# chr [1:7] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\" \"CYP1A1\" NA \"APOA5\"\n\n# Test to see if \"ACTN3\" or \"APO5A\" is in the snp_genes vector\n# If you are looking for more than one value, you must pass this as a vector\n\nc(\"ACTN3\",\"APOA5\") %in% snp_genes\n</code></pre> Output <pre><code>[1] TRUE TRUE\n</code></pre>"},{"location":"01-r-basics/#lists","title":"Lists","text":"<p>Lists are another form of data structure in R. Although it resembles vectors,  two key properties differentiates them and make lists extremely useful for more  complex data storage:</p> <ul> <li>Lists can contain data of multiple modes   Remember that vectors can only contain data of one mode.</li> <li>Lists can be nested   This means that a list can contain other lists. Vectors, on the other hand,    are flat (i.e., all values of a vector is laid out on a single level)</li> </ul> <p>Due to their flexibility, many complex analyses store data/return results using lists.</p> <p>Attribution</p> <p>Some of the content here was adapted from an excellent  tutorial which we highly recommend you read.</p>"},{"location":"01-r-basics/#creating-lists","title":"Creating lists","text":"<p>Let's begin by creating a list using existing vectors created  prior.</p> <p>r</p> <pre><code># We will replace the vector 'snp_genes' to its original values\nsnp_genes &lt;- c(\"OXTR\", \"ACTN3\", \"AR\", \"OPRM1\")\n\n# Create a list\nsnps_list &lt;- list(\n  genes = snp_genes,\n  reference_snps = snps,\n  chromosomes = snp_chromosomes,\n  positions = snp_positions\n)\n</code></pre> <p>Copy-pasting code</p> <p>Make sure to highlight, copy, paste, then run all lines of the  \"Create a list\" code block.</p> <p>We can see how R prints a list by calling it.</p> <p>r</p> <pre><code>snps_list\n</code></pre> Output <pre><code>$genes\n[1] \"OXTR\"  \"ACTN3\" \"AR\"    \"OPRM1\"\n\n$reference_snps\n[1] \"rs53576\"   \"rs1815739\" \"rs6152\"    \"rs1799971\"\n\n$chromosomes\n[1] \"3\"  \"11\" \"X\"  \"6\" \n\n$positions\n[1]   8762685  66560624  67545785 154039662\n</code></pre> <p>Here, we have a named list that contains the vectors <code>genes</code>,  <code>reference_snps</code>, <code>chromosomes</code>, and <code>positions</code>. We can also inspect the modes  of data stored in the list using <code>str()</code>.</p> <p>r</p> <pre><code>str(snps_list)\n</code></pre> Output <pre><code>List of 4\n $ genes         : chr [1:4] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\"\n $ reference_snps: chr [1:4] \"rs53576\" \"rs1815739\" \"rs6152\" \"rs1799971\"\n $ chromosomes   : chr [1:4] \"3\" \"11\" \"X\" \"6\"\n $ positions     : num [1:4] 8.76e+06 6.66e+07 6.75e+07 1.54e+08\n</code></pre> <p>Unnamed items in a list</p> <p>When we created our list, we assigned a name to each item within the list. However, this is not strictly necessary. Let's try it out and see what  happens:</p> <p>r</p> <pre><code># Create the list\nunnamed_snps_list &lt;- list(\n  snp_genes,\n  snps,\n  snp_chromosomes,\n  snp_positions\n)\n\n# Call the list\nunnamed_snps_list\n</code></pre> Output <pre><code>[[1]]\n[1] \"OXTR\"  \"ACTN3\" \"AR\"    \"OPRM1\"\n\n[[2]]\n[1] \"rs53576\"   \"rs1815739\" \"rs6152\"    \"rs1799971\"\n\n[[3]]\n[1] \"3\"  \"11\" \"X\"  \"6\" \n\n[[4]]\n[1]   8762685  66560624  67545785 154039662\n</code></pre> <p>Notice that the items are not named and are simply given a numeric index within double square brackets <code>[[1]]</code>. In fact, you can create a list with a mixture of named and unnamed items. While this is still a valid way to create lists, it is not very user-friendly as we have no way of telling what information is stored in each of the items. Ideally, you should assign names to each item in the list when creating it to easily identify the kinds of information stored within it.</p> <p>Importance of correct symbols for adding items to lists</p> <p>Notice that we have used the assignment operator <code>&lt;-</code> to create  <code>snps_list</code> and the equal symbol <code>=</code> to add vectors to each item in the  list. When creating a vector, you can use either symbol to achieve the same  goal. However, when creating lists, the distinction between symbols is  NOT a stylistic choice and will affect the output. We can see what  happens if we were to change the <code>=</code> operator to <code>&lt;-</code> within the brackets.</p> <p>r</p> <pre><code>wrong_operator &lt;- list(\n  genes &lt;- snp_genes,\n  reference_snps = snps,\n  chromosomes = snp_chromosomes,\n  positions = snp_positions\n)\n\n# Call the list\nwrong_operator\n</code></pre> Output <pre><code>[[1]]\n[1] \"OXTR\"  \"ACTN3\" \"AR\"    \"OPRM1\"\n\n$reference_snps\n[1] \"rs53576\"   \"rs1815739\" \"rs6152\"    \"rs1799971\"\n\n$chromosomes\n[1] \"3\"  \"11\" \"X\"  \"6\" \n\n$positions\n[1]   8762685  66560624  67545785 154039662\n</code></pre> <p>We can observe two things: </p> <ul> <li>The name for the first list item <code>genes</code> is now simply    a numeric index <code>[[1]]</code></li> <li>There is an additional object in the global environment called <code>genes</code></li> </ul> <p>Switching the assignment operator adds an unnamed item in the list,  and creates a vector object called <code>genes</code> in the global environment.  Make certain to use the correct operator when creating lists to avoid  unintentionally populating your working environment.</p>"},{"location":"01-r-basics/#refer-to-items-in-a-list","title":"Refer to items in a list","text":"<p>In the examples above, we refer to values in a vector using their indices  (e.g. <code>vector[c(2, 3)]</code>). For the named list we created, we can refer to the  name of the items themselves. Commonly, this is done using the <code>$</code> like so:  <code>list_name$object_name</code>. For example, we can retrieve gene positions from  <code>snps_list</code>:</p> <p>r</p> <pre><code>snps_list$positions\n</code></pre> Output <pre><code>[1]   8762685  66560624  67545785 154039662\n</code></pre> <p>There are also ways to refer to objects in a list using square brackets <code>[]</code>  (like for vectors). However, this method is more complex.  This section of the  linked tutorial provides a good analogy on how the brackets are interpreted in  R in the context of lists.</p>"},{"location":"01-r-basics/#add-or-replace-items-in-a-list","title":"Add or replace items in a list","text":"<p>We can also add items to lists. Let's add a logical vector to the list.</p> <p>r</p> <pre><code># Create logical vector\nsnps_DE &lt;- c(TRUE, FALSE, FALSE, TRUE)\n\n# Add to list\nsnps_list$DE_genes &lt;- snps_DE\n\n# Inspect list\nstr(snps_list)\n</code></pre> Output <pre><code>List of 5\n $ genes         : chr [1:4] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\"\n $ reference_snps: chr [1:4] \"rs53576\" \"rs1815739\" \"rs6152\" \"rs1799971\"\n $ chromosomes   : chr [1:4] \"3\" \"11\" \"X\" \"6\"\n $ positions     : num [1:4] 8.76e+06 6.66e+07 6.75e+07 1.54e+08\n $ DE_genes      : logi [1:4] TRUE FALSE FALSE TRUE\n</code></pre> <p>Now, <code>snps_list</code> has 5 items, the last of which is a logical vector that we  just added.</p> <p>To replace items in a list, we refer to the item, then assign it something  else. Let's say we want the <code>DE_genes</code> to be in numeric, instead of logical  mode.</p> <p>r</p> <pre><code># Replace DE_genes with a character vector\nsnps_list$DE_genes &lt;- as.numeric(snps_DE)\n\n# Inspect list\nstr(snps_list)\n</code></pre> Output <pre><code>List of 5\n $ genes         : chr [1:4] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\"\n $ reference_snps: chr [1:4] \"rs53576\" \"rs1815739\" \"rs6152\" \"rs1799971\"\n $ chromosomes   : chr [1:4] \"3\" \"11\" \"X\" \"6\"\n $ positions     : num [1:4] 8.76e+06 6.66e+07 6.75e+07 1.54e+08\n $ DE_genes      : num [1:4] 1 0 0 1\n</code></pre> <p>Notice that <code>DE_genes</code> has turned into numeric mode from its original logical  mode, where <code>TRUE</code> is <code>1</code> and <code>FALSE</code> is <code>0</code>.</p> <p>Up till now, we have made a list that contain items with a vector length of 4.  There is no requirement that all items in lists to must have the same length.  Lists can have any number of items of different lengths. For example, let's add  a single number into the list:</p> <p>r</p> <pre><code># Add a number to the list\nsnps_list$sig_threshold &lt;- 0.05\n\n# Inspect list\nstr(snps_list)\n</code></pre> Output <pre><code>List of 6\n $ genes         : chr [1:4] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\"\n $ reference_snps: chr [1:4] \"rs53576\" \"rs1815739\" \"rs6152\" \"rs1799971\"\n $ chromosomes   : chr [1:4] \"3\" \"11\" \"X\" \"6\"\n $ positions     : num [1:4] 8.76e+06 6.66e+07 6.75e+07 1.54e+08\n $ DE_genes      : num [1:4] 1 0 0 1\n $ sig_threshold : num 0.05\n</code></pre>"},{"location":"01-r-basics/#subset-or-remove-objects-from-a-list","title":"Subset or remove objects from a list","text":"<p>Single square brackets <code>[]</code> can be used to subset a list based on the item's  index or name. The following code will subset the items <code>genes</code>,  <code>reference_snps</code>, and <code>sig_threshold</code> from <code>snps_list</code>.</p> <p>r</p> <pre><code># Method 1: Use index\n# We know the index of genes (1), reference_snps (2) and sig_threshold (6). \nsub_snps_list &lt;- snps_list[c(1:2, 6)]\n\n# Inspect list\nstr(sub_snps_list)\n</code></pre> Output <pre><code>List of 3\n $ genes         : chr [1:4] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\"\n $ reference_snps: chr [1:4] \"rs53576\" \"rs1815739\" \"rs6152\" \"rs1799971\"\n $ sig_threshold : num 0.05\n</code></pre> <p>r</p> <pre><code># Method 2: Use names\nsub_snps_list &lt;- snps_list[c(\"genes\", \"reference_snps\", \"sig_threshold\")]\n\n# Inspect list\nstr(sub_snps_list)\n</code></pre> Output <pre><code>List of 3\n $ genes         : chr [1:4] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\"\n $ reference_snps: chr [1:4] \"rs53576\" \"rs1815739\" \"rs6152\" \"rs1799971\"\n $ sig_threshold : num 0.05\n</code></pre> <p>List bracket notation</p> <p>When subsetting a list using single square brackets <code>[]</code>, the result is  always a list. To access the vector directly, we need to use double square brackets <code>[[]]</code>. For example:</p> <p>r</p> <pre><code># Return the vector in a list\nsnps_list[\"chromosomes\"]\n\n# Return the vector directly\nsnps_list[[\"chromosomes\"]]\n</code></pre> Output <pre><code>$chromosomes\n[1] \"3\"  \"11\" \"X\"  \"6\"\n\n[1] \"3\"  \"11\" \"X\"  \"6\"\n</code></pre> <p>To remove objects in a list, we first refer to it, then assign it as <code>NULL</code>.</p> <p>r</p> <pre><code># Remove sig_threshold\nsub_snps_list$sig_threshold &lt;- NULL\n\n# Inspect list\nstr(sub_snps_list)\n</code></pre> Output <pre><code>List of 2\n $ genes         : chr [1:4] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\"\n $ reference_snps: chr [1:4] \"rs53576\" \"rs1815739\" \"rs6152\" \"rs1799971\"\n</code></pre> <p>Et voil\u00e0! The numeric vector <code>sig_threshold</code> is no longer a part of  <code>sub_snps_list</code>.</p>"},{"location":"01-r-basics/#nested-list","title":"Nested list","text":"<p>A defining feature of lists is that it can be nested (i.e., lists can be stored inside of a list). This property allows the storage of data that are structured hierarchically or in a tree-like fashion (i.e., dendrograms). It is also useful for storing different types of data in an organised manner (e.g., a list of model values with a nested list that contains sample information or metadata). You will undoubtedly encounter complex nested list structures in your R journey. The majority of the time, we are only concerned with referring to or subsetting nested lists. With that in mind, let's start with creating a nested list followed by an example on subsetting.</p> <p>r</p> <pre><code># Create nested list\nnested_snps_list &lt;- list(\n  gene = snp_genes,\n  snp_info = list(\n    reference = snps,\n    chromosome = snp_chromosomes,\n    position = snp_positions\n  ),\n  result = list(\n    DE = snps_DE,\n    threshold = 0.05\n  ),\n  metadata = list(\n    sample_group = list(\n      A = c(\"S1\", \"S2\"),\n      B = \"S3\",\n      C = \"S4\"\n    )\n  )\n)\n</code></pre> <p>Reminder</p> <p>Again, make sure to highlight, copy, paste, and run the entire code block!</p> <p>Inspect the list structure:</p> <p>r</p> <pre><code>str(nested_snps_list)\n</code></pre> Output <pre><code>List of 4\n $ gene    : chr [1:4] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\"\n $ snp_info:List of 3\n  ..$ reference : chr [1:4] \"rs53576\" \"rs1815739\" \"rs6152\" \"rs1799971\"\n  ..$ chromosome: chr [1:4] \"3\" \"11\" \"X\" \"6\"\n  ..$ position  : num [1:4] 8.76e+06 6.66e+07 6.75e+07 1.54e+08\n $ result  :List of 2\n  ..$ DE       : logi [1:4] TRUE FALSE FALSE TRUE\n  ..$ threshold: num 0.05\n $ metadata:List of 1\n  ..$ sample_group:List of 3\n  .. ..$ A: chr [1:2] \"S1\" \"S2\"\n  .. ..$ B: chr \"S3\"\n  .. ..$ C: chr \"S4\"\n</code></pre> <p>Phew! There's quite a bit of information here! Let's break it down.</p> <ul> <li>We have created a list with 4 objects, each of which contain different    objects and modes: list, character, numeric, and logical.</li> <li><code>snp_info</code> and <code>result</code> are nested lists with structures we have encountered    before.<ul> <li>They each have vectors of varying modes.</li> <li><code>result</code> has vectors of varying lengths.</li> </ul> </li> <li>The nested list <code>metadata</code> is the parent of <code>sample_group</code>.<ul> <li><code>sample_group</code> has children <code>A</code>, <code>B</code>, and <code>C</code>, all of which are    character vectors.</li> </ul> </li> </ul> <p>Now we can subset/retrieve some of the information in the nested list. As we  are working with named lists (and sub-lists), it is easier to use the <code>$</code>  method. Let's subset the <code>chromosome</code> vector</p> <p>r</p> <pre><code>nested_snps_list$snp_info$chromosome\n</code></pre> Output <pre><code>[1] \"3\"  \"11\" \"X\"  \"6\" \n</code></pre> <p>If you want to use the index and square brackets method:</p> <p>r</p> <pre><code>nested_snps_list[[2]][[2]]\n</code></pre> Output <pre><code>[1] \"3\"  \"11\" \"X\"  \"6\" \n</code></pre> <p>You can read the above code as \"the second item (here, a character vector) of  the second item (a list)\"</p> <p>You can retrieve objects from deeply nested lists as long as you know the  object's name or index, and how it is structured (parent-child hierarchy).</p>"},{"location":"01-r-basics/#review-exercises","title":"Review exercises","text":"<p>Exercise 1</p> <p>What data modes are the following vectors?</p> <p>a. <code>snps</code>  b. <code>snp_chromosomes</code>  c. <code>snp_positions</code></p> Solution <p>Use <code>mode()</code> to find out.</p> <p>a. Character  b. Character  c. Numeric</p> <p>Exercise 2</p> <p>Add the following values to the specified vectors: </p> <p>a. To the <code>snps</code> vector add: \u201crs662799\u201d  b. To the <code>snp_chromosomes</code> vector add: 11  c. To the <code>snp_positions</code> vector add: 116792991</p> Solution <pre><code># Answer (a)\nsnps &lt;- c(snps, \"rs662799\")\n\n# Answer (b)\nsnp_chromosomes &lt;- c(snp_chromosomes, \"11\") # Did you use quotes?\n\n# Answer (c)\nsnp_positions &lt;- c(snp_positions, 116792991)\n</code></pre> <p>Exercise 3</p> <p>Make the following change to the <code>snp_genes</code> vector:</p> <p>Hint: Your vector should look like this in \u2018Environment\u2019:  <code>chr [1:7] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\" \"CYP1A1\" NA \"APOA5\"</code>.  If not recreate the vector by running this: </p> <p>r</p> <pre><code>snp_genes &lt;- c(\"OXTR\", \"ACTN3\", \"AR\", \"OPRM1\", \"CYP1A1\", NA, \"APOA5\")\n</code></pre> <p>a. Create a new version of <code>snp_genes</code> that does not contain \"CYP1A1\" and then  b. Add 2 NA values to the end of <code>snp_genes</code></p> Solution <pre><code># Answer (a)\nsnp_genes &lt;- snp_genes[-5]\n# or use logical subsetting\nsnp_genes &lt;- snp_genes[snp_genes != \"CYP1A1\"]\n\n# Answer (c)\nsnp_genes &lt;- c(snp_genes, NA, NA)\n</code></pre> <p>Exercise 4</p> <p>Using indexing, create a new vector named <code>combined</code> that contains:</p> <ul> <li>The the 1<sup>st</sup> value in <code>snp_genes</code></li> <li>The 1<sup>st</sup> value in <code>snps</code></li> <li>The 1<sup>st</sup> value in <code>snp_chromosomes</code></li> <li>The 1<sup>st</sup> value in <code>snp_positions</code></li> </ul> Solution <pre><code>combined &lt;- c(\n  snp_genes[1], \n  snps[1], \n  snp_chromosomes[1], \n  snp_positions[1]\n)\n</code></pre> <p>Exercise 5</p> <p>What type of data is <code>combined</code>?</p> Solution <p>It is a character vector. Use <code>typeof()</code> to find out.</p>"},{"location":"02-data-prelude/","title":"Introduction to the example dataset and file type","text":"<p>Learning outcomes</p> Key pointsObjectivesQuestions <ul> <li>The dataset comes from a real world experiment in E. coli.</li> <li>Publicly available FASTQ files can be downloaded from NCBI SRA.</li> <li>Several steps are taken outside of R/RStudio to create VCF files from   FASTQ files.</li> <li>VCF files store variant calls in a special format.</li> </ul> <ul> <li>Know what the example dataset represents</li> <li>Know the concepts of how VCF files are generated</li> </ul> <ul> <li>What data are we using in the lesson?</li> <li>What are VCF files?</li> </ul>"},{"location":"02-data-prelude/#preface","title":"Preface","text":"<p>The Intro to R and RStudio for Genomics is a part of the Genomics Data Carpentry lessons. In this lesson we will learn the necessary skill sets for R and RStudio and apply them directly to a real next-generation sequencing (NGS) data in the variant calling format (VCF) file type. Previous Genomics Data Carpentry lessons teach learners how to generate a VCF file from FASTQ files downloaded from NCBI Sequence Read Archive (SRA), so we won't cover that here. Instead, in this episode we will give a brief overview of the data and a what VCF file types are for those who wish to teach the Intro to R and RStudio for Genomics lesson independently of the Genomics Data Carpentry lessons.</p> <p>This dataset was selected for several reasons, including:</p> <ul> <li>Simple, but iconic NGS-problem: Examine a population where we want     to characterize changes in sequence a priori</li> <li>Dataset publicly available - in this case through the NCBI SRA     (http://www.ncbi.nlm.nih.gov/sra)</li> </ul>"},{"location":"02-data-prelude/#introduction-to-the-dataset","title":"Introduction to the dataset","text":"<p>Microbes are ideal organisms for exploring 'Long-term Evolution Experiments' (LTEEs) - thousands of generations can be generated and stored in a way that would be virtually impossible for more complex eukaryotic systems. In Tenaillon et al. (2016), 12 populations of Escherichia coli were propagated for more than 50,000 generations in a glucose-limited minimal medium. This medium was supplemented with citrate which E. coli cannot metabolize in the aerobic conditions of the experiment. Sequencing of the populations at regular time points reveals that spontaneous citrate-using mutants (Cit+) appeared in a population of E.coli (designated Ara-3) at around 31,000 generations. It should be noted that spontaneous Cit+ mutants are extraordinarily rare - inability to metabolize citrate is one of the defining characters of the E. coli species. Eventually, Cit+ mutants became the dominant population as the experimental growth medium contained a high concentration of citrate relative to glucose. Around the same time that this mutation emerged, another phenotype become prominent in the Ara-3 population. Many E. coli began to develop excessive numbers of mutations, meaning they became hypermutable.</p> <p>Strains from generation 0 to generation 50,000 were sequenced, including ones that were both Cit+ and Cit- and hypermutable in later generations.</p> <p>For the purposes of this workshop we're going to be working with 3 of the sequence reads from this experiment.</p> SRA run number Clone Generation Cit Hypermutable Read length Sequencing depth SRR2589044 REL2181A 5,000 Unknown None 150 60.2 SRR2584863 REL7179B 15,000 Unknown None 150 88 SRR2584866 REL11365 50,000 Cit+ plus plus 138.3 <p>We want to be able to look at differences in mutation rates between hypermutable and non-hypermutable strains. We also want to analyze the sequences to figure out what changes occurred in genomes to make the strains Cit+. Ultimately, we will use R to answer these questions:</p> <ul> <li>How many base pair changes are there between the Cit+ and Cit-     strains?</li> <li>What are the base pair changes between strains?</li> </ul>"},{"location":"02-data-prelude/#how-vcf-files-are-generated","title":"How VCF files are generated","text":"<p>Publicly accessible sequencing files in FASTQ formats can be downloaded from NCBI SRA. However, FASTQ files contain unaligned sequences of varying quality, and require clean up and alignment steps before variants can be called from the reference genome.</p> <p>There are five steps we must take to transform raw FASTQ files into variant calls (VCF files). At each of the five steps we will be using specialized, non-R based bioinformatics tools:</p> <p> </p> Variant calling workflow"},{"location":"02-data-prelude/#how-variant-calls-are-stored-in-vcf-files","title":"How variant calls are stored in VCF files","text":"<p>VCF files contain variants that were called against a reference genome. These files are slightly more complicated than regular tables you can open using programs like Excel and contain two sections: header and records.</p> <p>Below you will see the header (which describes the format), the time and date the file was created, the version of <code>bcftools</code> that was used, the command line parameters used, and some additional information:</p> <pre><code>##fileformat=VCFv4.2\n##FILTER=&lt;ID=PASS,Description=\"All filters passed\"&gt;\n##bcftoolsVersion=1.8+htslib-1.8\n##bcftoolsCommand=mpileup -O b -o results/bcf/SRR2584866_raw.bcf -f data/ref_genome/ecoli_rel606.fasta results/bam/SRR2584866.aligned.sorted.bam\n##reference=file://data/ref_genome/ecoli_rel606.fasta\n##contig=&lt;ID=CP000819.1,length=4629812&gt;\n##ALT=&lt;ID=*,Description=\"Represents allele(s) other than observed.\"&gt;\n##INFO=&lt;ID=INDEL,Number=0,Type=Flag,Description=\"Indicates that the variant is an INDEL.\"&gt;\n##INFO=&lt;ID=IDV,Number=1,Type=Integer,Description=\"Maximum number of reads supporting an indel\"&gt;\n##INFO=&lt;ID=IMF,Number=1,Type=Float,Description=\"Maximum fraction of reads supporting an indel\"&gt;\n##INFO=&lt;ID=DP,Number=1,Type=Integer,Description=\"Raw read depth\"&gt;\n##INFO=&lt;ID=VDB,Number=1,Type=Float,Description=\"Variant Distance Bias for filtering splice-site artefacts in RNA-seq data (bigger is better)\",Version=\n##INFO=&lt;ID=RPB,Number=1,Type=Float,Description=\"Mann-Whitney U test of Read Position Bias (bigger is better)\"&gt;\n##INFO=&lt;ID=MQB,Number=1,Type=Float,Description=\"Mann-Whitney U test of Mapping Quality Bias (bigger is better)\"&gt;\n##INFO=&lt;ID=BQB,Number=1,Type=Float,Description=\"Mann-Whitney U test of Base Quality Bias (bigger is better)\"&gt;\n##INFO=&lt;ID=MQSB,Number=1,Type=Float,Description=\"Mann-Whitney U test of Mapping Quality vs Strand Bias (bigger is better)\"&gt;\n##INFO=&lt;ID=SGB,Number=1,Type=Float,Description=\"Segregation based metric.\"&gt;\n##INFO=&lt;ID=MQ0F,Number=1,Type=Float,Description=\"Fraction of MQ0 reads (smaller is better)\"&gt;\n##FORMAT=&lt;ID=PL,Number=G,Type=Integer,Description=\"List of Phred-scaled genotype likelihoods\"&gt;\n##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=\"Genotype\"&gt;\n##INFO=&lt;ID=ICB,Number=1,Type=Float,Description=\"Inbreeding Coefficient Binomial test (bigger is better)\"&gt;\n##INFO=&lt;ID=HOB,Number=1,Type=Float,Description=\"Bias in the number of HOMs number (smaller is better)\"&gt;\n##INFO=&lt;ID=AC,Number=A,Type=Integer,Description=\"Allele count in genotypes for each ALT allele, in the same order as listed\"&gt;\n##INFO=&lt;ID=AN,Number=1,Type=Integer,Description=\"Total number of alleles in called genotypes\"&gt;\n##INFO=&lt;ID=DP4,Number=4,Type=Integer,Description=\"Number of high-quality ref-forward , ref-reverse, alt-forward and alt-reverse bases\"&gt;\n##INFO=&lt;ID=MQ,Number=1,Type=Integer,Description=\"Average mapping quality\"&gt;\n##bcftools_callVersion=1.8+htslib-1.8\n##bcftools_callCommand=call --ploidy 1 -m -v -o results/bcf/SRR2584866_variants.vcf results/bcf/SRR2584866_raw.bcf; Date=Tue Oct  9 18:48:10 2018\n</code></pre> <p>Followed by information on each of the variations observed:</p> <pre><code>#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  results/bam/SRR2584866.aligned.sorted.bam\nCP000819.1      1521    .       C       T       207     .       DP=9;VDB=0.993024;SGB=-0.662043;MQSB=0.974597;MQ0F=0;AC=1;AN=1;DP4=0,0,4,5;MQ=60\nCP000819.1      1612    .       A       G       225     .       DP=13;VDB=0.52194;SGB=-0.676189;MQSB=0.950952;MQ0F=0;AC=1;AN=1;DP4=0,0,6,5;MQ=60\nCP000819.1      9092    .       A       G       225     .       DP=14;VDB=0.717543;SGB=-0.670168;MQSB=0.916482;MQ0F=0;AC=1;AN=1;DP4=0,0,7,3;MQ=60\nCP000819.1      9972    .       T       G       214     .       DP=10;VDB=0.022095;SGB=-0.670168;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,2,8;MQ=60      GT:PL\nCP000819.1      10563   .       G       A       225     .       DP=11;VDB=0.958658;SGB=-0.670168;MQSB=0.952347;MQ0F=0;AC=1;AN=1;DP4=0,0,5,5;MQ=60\nCP000819.1      22257   .       C       T       127     .       DP=5;VDB=0.0765947;SGB=-0.590765;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,2,3;MQ=60      GT:PL\nCP000819.1      38971   .       A       G       225     .       DP=14;VDB=0.872139;SGB=-0.680642;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,4,8;MQ=60      GT:PL\nCP000819.1      42306   .       A       G       225     .       DP=15;VDB=0.969686;SGB=-0.686358;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,5,9;MQ=60      GT:PL\nCP000819.1      45277   .       A       G       225     .       DP=15;VDB=0.470998;SGB=-0.680642;MQSB=0.95494;MQ0F=0;AC=1;AN=1;DP4=0,0,7,5;MQ=60\nCP000819.1      56613   .       C       G       183     .       DP=12;VDB=0.879703;SGB=-0.676189;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,8,3;MQ=60      GT:PL\nCP000819.1      62118   .       A       G       225     .       DP=19;VDB=0.414981;SGB=-0.691153;MQSB=0.906029;MQ0F=0;AC=1;AN=1;DP4=0,0,8,10;MQ=59\nCP000819.1      64042   .       G       A       225     .       DP=18;VDB=0.451328;SGB=-0.689466;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,7,9;MQ=60      GT:PL\n</code></pre> <p>The first few columns represent the information we have about a predicted variation.</p> Column Information CHROM Contig location where the variation occurs POS Position within the contig where the variation occurs ID A <code>.</code> until we add annotation information REF Reference genotype (forward strand) ALT Sample genotype (forward strand) QUAL Phred-scaled probability that the observed variant exists at this site (higher is better) FILTER A <code>.</code> if no quality filters have been applied, PASS if a filter is passed, or the name of the filters this variant failed <p>In an ideal world, the information in the <code>QUAL</code> column would be all we needed to filter out bad variant calls. However, in reality we need to filter on multiple other metrics.</p> <p>The last two columns contain the genotypes and can be tricky to decode.</p> Column Information FORMAT Lists in order the metrics presented int he final column results Lists the values associated with those metrics in order <p>For our file, the metrics presented are GT:PL:GQ.</p> Metric Definition AD, DP The depth per allele by sample and coverage GT The genotype for the sample at this loci. For a diploid organism, this field indicates the two alleles carried by the sample, encoded by a 0 for the REF allele, 1 for the first ALT allele, 2 for the second ALT allele, etc. A 0/0 means homozygous reference, 0/1 is heterozygous, and 1/1 is homozygous for the alternate allele. PL The likelihoods of the given genotypes. GQ The Phred-scaled confidence for the genotype. <p>For more information on VCF files visit The Broad Institute's VCF guide.</p> <p>References</p> <p>Tenaillon O, Barrick JE, Ribeck N, Deatherage DE, Blanchard JL, Dasgupta A, Wu GC, Wielgoss S, Cruveiller S, M\u00e9digue C, Schneider D, Lenski RE. Tempo and mode of genome evolution in a 50,000-generation experiment (2016) Nature. 536(7615): 165\u2013170.  Paper, Supplemental materials,  Data on NCBI SRA,  Data on EMBL-EBI ENA</p> <p>This episode was adapted from the Data Carpentry Genomic lessons:</p> <ul> <li>Project organization and management for     Genomics</li> <li>Data wrangling and processing for     genomics</li> </ul>"},{"location":"03-basics-factors-dataframes/","title":"R Basics continued - factors and data frames","text":"<p>Learning outcomes</p> Key pointsObjectivesQuestions <ul> <li>It is easy to import data into R from tabular formats including Excel.   However, you still need to check that R has imported and interpreted   your data correctly</li> <li>There are best practices for organizing your data (keeping it tidy)   and R is great for this</li> <li>Base R has many useful functions for manipulating your data, but all   of R's capabilities are greatly enhanced by software packages   developed by the community</li> </ul> <ul> <li>Understand the basic principle of tidy datasets</li> <li>Be able to load a tabular dataset using base R functions</li> <li>Be able to determine the structure of a data frame including its   dimensions and the datatypes of variables</li> <li>Be able to subset/retrieve values from a data frame</li> <li>Understand how R may coerce data into different modes</li> <li>Be able to change the mode of an object</li> <li>Understand that R uses factors to store and manipulate categorical   data</li> <li>Be able to manipulate a factor, including subsetting and reordering</li> <li>Be able to apply an arithmetic function to a data frame</li> <li>Be able to coerce the class of an object (including variables in a   data frame)</li> <li>Be able to import data from Excel</li> <li>Be able to save a data frame as a delimited file</li> </ul> <ul> <li>How do I get started with tabular data (e.g.,\u00a0spreadsheets) in R?</li> <li>What are some best practices for reading data into R?</li> <li>How do I save tabular data generated in R?</li> </ul>"},{"location":"03-basics-factors-dataframes/#working-with-spreadsheets-tabular-data","title":"Working with spreadsheets (tabular data)","text":"<p>A substantial amount of the data we work with in genomics will be tabular data, this is data arranged in rows and columns - also known as spreadsheets. We could write a whole lesson on how to work with spreadsheets effectively (actually we did). For our purposes, we want to remind you of a few principles before we work with our first set of example data:</p> <p>1) Keep raw data separate from analyzed data</p> <p>This is principle number one because if you can't tell which files are the original raw data, you risk making some serious mistakes (e.g.,\u00a0drawing conclusion from data which have been manipulated in some unknown way).</p> <p>2) Keep spreadsheet data Tidy</p> <p>The simplest principle of Tidy data is that we have one row in our spreadsheet for each observation or sample, and one column for every variable that we measure or report on. As simple as this sounds, it's very easily violated. Most data scientists agree that significant amounts of their time is spent tidying data for analysis. Read more about data organization in our lesson and in this paper.</p> <p>3) Trust but verify</p> <p>Finally, while you don't need to be paranoid about data, you should have a plan for how you will prepare it for analysis. This a focus of this lesson. You probably already have a lot of intuition, expectations, assumptions about your data - the range of values you expect, how many values should have been recorded, etc. Of course, as the data get larger our human ability to keep track will start to fail (and yes, it can fail for small data sets too). R will help you to examine your data so that you can have greater confidence in your analysis and its reproducibility.</p> <p>Keeping your raw data separate</p> <p>When you work with data in R, you are not changing the original file you loaded that data from. This is different from (for example) working with a spreadsheet program where changing the value of the cell leaves you one \"save\"-click away from overwriting the original file. You have to purposely use a writing function (e.g.,\u00a0<code>write.csv()</code>) to save data loaded into R. In that case, be sure to save the manipulated data into a new file. More on this later in the lesson.</p>"},{"location":"03-basics-factors-dataframes/#importing-tabular-data-into-r","title":"Importing tabular data into R","text":"<p>There are several ways to import data into R. For our purpose here, we will focus on using the tools every R installation comes with (so called \"base\" R) to import a comma-delimited file containing the results of our variant calling workflow. We will need to load the sheet using a function called <code>read.csv()</code>.</p> <p>Exercise: Review the arguments of the <code>read.csv()</code> function</p> <p>Before using the <code>read.csv()</code> function, use R's help feature to answer the following questions.</p> <p>Hint: Entering '?' before the function name and then running that line will bring up the help documentation. Also, when reading this particular help be careful to pay attention to the 'read.csv' expression under the 'Usage' heading. Other answers will be in the 'Arguments' heading.</p> <p>A)  What is the default parameter for 'header' in the <code>read.csv()</code>     function?</p> <p>B)  What argument would you have to change to read a file that was     delimited by semicolons (;) rather than commas?</p> <p>C)  What argument would you have to change to read file in which     numbers used commas for decimal separation (i.e.,\u00a01,00)?</p> <p>D)  What argument would you have to change to read in only the first     10,000 rows of a very large file?</p> Solution <p>A)  The <code>read.csv()</code> function has the argument 'header' set to <code>TRUE</code>     by default. This means the function always assumes the first row     is header information, (i.e.,\u00a0column names)</p> <p>B)  The <code>read.csv()</code> function has the argument 'sep' set to \",\".     This means the function assumes commas are used as delimiters,     as you would expect. Changing this parameter (e.g.,\u00a0<code>sep=\";\"</code>)     would tell R to interpret semicolons as delimiters.</p> <p>C)  Although it is not listed in the <code>read.csv()</code> usage,     <code>read.csv()</code> is a \"version\" of the function <code>read.table()</code> and     accepts all its arguments. If you set <code>dec=\",\"</code> you could change     the decimal operator. We'd probably assume the delimiter is some     other character.</p> <p>D)  You can set <code>nrow</code> to a numeric value (e.g.,\u00a0<code>nrow=10000</code>) to     choose how many rows of a file you read in. This may be useful     for very large files where not all the data is needed to test     some data cleaning steps you are applying.</p> <p>Hopefully, this exercise gets you thinking about using the provided help documentation in R. There are many arguments that exist, but which we wont have time to cover. </p> <p>Now, let's read in the file <code>combined_tidy_vcf.csv</code> which will be located in <code>/home/shared/$USER/R4Genomics/</code>. Call/assign this data <code>variants</code>.  The first argument to pass to our <code>read.csv()</code> function is the file path for our data. The file path must be in quotes and now is a good time to remember to use tab autocompletion. If you use tab autocompletion you avoid typos and errors in file paths. Use it!</p> <p>r</p> <pre><code># Read in a CSV file and save it as 'variants'\n\nvariants &lt;- read.csv(\"/home/shared/&lt;USERID&gt;/R4Genomics/combined_tidy_vcf.csv\")\n</code></pre> What if you want to access this file on your personal computer? <pre><code># Read the csv directly from our github repository\n\nvariants &lt;- read.csv('https://raw.githubusercontent.com/GenomicsAotearoa/Introduction-to-R/refs/heads/main/combined_tidy_vcf.csv')\n</code></pre> <p>One of the first things you should notice is that in the Environment window, you have the <code>variants</code> object, listed as 801 obs. (observations/rows) of 29 variables (columns). Double-clicking on the name of the object will open a view of the data in a new tab.</p> <p></p>"},{"location":"03-basics-factors-dataframes/#summarizing-and-determining-the-structure-of-a-data-frame","title":"Summarizing and determining the structure of a data frame.","text":"<p>A data frame is the standard way to store tabular data in R. A data frame could also be thought of as a collection of vectors, all of which have the same length. Using only two functions, we can learn a lot about out data frame including some summary statistics as well as the \"structure\" of the data frame. Let's examine what each of these functions can tell us:</p> <p>r</p> <pre><code># Get summary statistics on a data frame\n\nsummary(variants)\n</code></pre> Output <pre><code> sample_id            CHROM                POS             ID              REF           \nLength:801         Length:801         Min.   :   1521   Mode:logical   Length:801        \nClass :character   Class :character   1st Qu.:1115970   NA's:801       Class :character  \nMode  :character   Mode  :character   Median :2290361                  Mode  :character  \n                                      Mean   :2243682                                    \n                                      3rd Qu.:3317082                                    \n                                      Max.   :4629225                                    \n\n    ALT                 QUAL          FILTER          INDEL              IDV              IMF        \nLength:801         Min.   :  4.385   Mode:logical   Mode :logical   Min.   : 2.000   Min.   :0.5714  \nClass :character   1st Qu.:139.000   NA's:801       FALSE:700       1st Qu.: 7.000   1st Qu.:0.8824  \nMode  :character   Median :195.000                  TRUE :101       Median : 9.000   Median :1.0000  \n                   Mean   :172.276                                  Mean   : 9.396   Mean   :0.9219  \n                   3rd Qu.:225.000                                  3rd Qu.:11.000   3rd Qu.:1.0000  \n                   Max.   :228.000                                  Max.   :20.000   Max.   :1.0000  \n                                                                    NA's   :700      NA's   :700     \n      DP             VDB                 RPB              MQB              BQB        \nMin.   : 2.00   Min.   :0.0005387   Min.   :0.0000   Min.   :0.0000   Min.   :0.1153  \n1st Qu.: 7.00   1st Qu.:0.2180410   1st Qu.:0.3776   1st Qu.:0.1070   1st Qu.:0.6963  \nMedian :10.00   Median :0.4827410   Median :0.8663   Median :0.2872   Median :0.8615  \nMean   :10.57   Mean   :0.4926291   Mean   :0.6970   Mean   :0.5330   Mean   :0.7784  \n3rd Qu.:13.00   3rd Qu.:0.7598940   3rd Qu.:1.0000   3rd Qu.:1.0000   3rd Qu.:1.0000  \nMax.   :79.00   Max.   :0.9997130   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n                                    NA's   :773      NA's   :773      NA's   :773     \n     MQSB              SGB               MQ0F           ICB            HOB                AC   \nMin.   :0.01348   Min.   :-0.6931   Min.   :0.00000   Mode:logical   Mode:logical   Min.   :1  \n1st Qu.:0.95494   1st Qu.:-0.6762   1st Qu.:0.00000   NA's:801       NA's:801       1st Qu.:1  \nMedian :1.00000   Median :-0.6620   Median :0.00000                                 Median :1  \nMean   :0.96428   Mean   :-0.6444   Mean   :0.01127                                 Mean   :1  \n3rd Qu.:1.00000   3rd Qu.:-0.6364   3rd Qu.:0.00000                                 3rd Qu.:1  \nMax.   :1.01283   Max.   :-0.4536   Max.   :0.66667                                 Max.   :1  \nNA's   :48                                                                                     \n      AN        DP4                  MQ           Indiv              gt_PL               gt_GT  \nMin.   :1   Length:801         Min.   :10.00   Length:801         Length:801         Min.   :1  \n1st Qu.:1   Class :character   1st Qu.:60.00   Class :character   Class :character   1st Qu.:1  \nMedian :1   Mode  :character   Median :60.00   Mode  :character   Mode  :character   Median :1  \nMean   :1                      Mean   :58.19                                         Mean   :1  \n3rd Qu.:1                      3rd Qu.:60.00                                         3rd Qu.:1  \nMax.   :1                      Max.   :60.00                                         Max.   :1  \n\ngt_GT_alleles     \nLength:801        \nClass :character  \nMode  :character\n</code></pre> <p>Our data frame has 29 variables, so we get 29 fields that summarize the data. The <code>QUAL</code>, <code>IMF</code>, and <code>VDB</code> variables (and several others) are numerical data and so you get summary statistics on the minimum and maximum  values for these columns, as well as mean, median, and 1<sup>st</sup> and 3<sup>rd</sup> quantile.  Many of the other variables (e.g., <code>sample_id</code>) are treated as character data  (more on this in a bit). There is a lot to work with, so we will subset the  first three columns into a new data frame using the <code>data.frame()</code> function.</p> <p>r</p> <pre><code># Put the first three columns of variants into a new data frame called subset_variants\n\nsubset_variants &lt;- variants[, c(1:3, 6)]\n</code></pre> <p>Now, let's use the <code>str()</code> (structure) function to look a little more closely at how data frames work:</p> <p>r</p> <pre><code># Get the structure of a data frame\n\nstr(subset_variants)\n</code></pre> Output <pre><code>'data.frame':   801 obs. of  4 variables:\n $ sample_id: chr  \"SRR2584863\" \"SRR2584863\" \"SRR2584863\" \"SRR2584863\" ...\n $ CHROM    : chr  \"CP000819.1\" \"CP000819.1\" \"CP000819.1\" \"CP000819.1\" ...\n $ POS      : int  9972 263235 281923 433359 473901 648692 1331794 1733343 2103887 2333538 ...\n $ ALT      : chr  \"G\" \"T\" \"T\" \"CTTTTTTTT\" ...\n</code></pre> <p>Ok, that is a lot up unpack! Some things to notice.</p> <ul> <li>The object type <code>data.frame</code> is displayed in the first row along with its   dimensions, in this case 801 observations (rows) and 4 variables (columns).</li> <li>Each variable (column) has a name (e.g., <code>sample_id</code>). This is followed   by the object mode (e.g., chr, int, etc.). Notice that before each   variable name there is a <code>$</code> (this will be important later).</li> </ul>"},{"location":"03-basics-factors-dataframes/#subsetting-data-frames","title":"Subsetting data frames","text":"<p>Next, we are going to talk about how you can get specific values from data frames.</p> <p>The first thing to remember is that a data frame is two-dimensional (rows and columns). Therefore, to select a specific value we will will once again use <code>[]</code> (bracket) notation, but we will specify more than one value (except in some cases where we are taking a range).</p> <p>Exercise: Subsetting a data frame</p> <p>Try the following indices and functions and try to figure out what they return</p> <p>a.  <code>variants[1, 1]</code></p> <p>b.  <code>variants[2, 4]</code></p> <p>c.  <code>variants[801, 29]</code></p> <p>d.  <code>variants[2,]</code></p> <p>e.  <code>variants[-1,]</code></p> <p>f.  <code>variants[1:4, 1]</code></p> <p>g.  <code>variants[1:10, c(\"REF\",\"ALT\")]</code></p> <p>h.  <code>variants[, c(\"sample_id\")]</code></p> <p>i.  <code>head(variants)</code></p> <p>j.  <code>tail(variants)</code></p> <p>k.  <code>variants$sample_id</code></p> <p>l.  <code>variants[variants$REF == \"A\",]</code></p> Output <p>a. <pre><code>[1] \"SRR2584863\"\n</code></pre></p> <p>b. <pre><code>[1] NA\n</code></pre></p> <p>c. <pre><code>[1] \"T\"\n</code></pre></p> <p>d. <pre><code>    sample_id      CHROM    POS ID REF ALT QUAL FILTER INDEL IDV IMF DP      VDB RPB MQB BQB\n2  SRR2584863 CP000819.1 263235 NA   G   T   85     NA FALSE  NA  NA  6 0.096133   1   1   1\n    MQSB       SGB     MQ0F ICB HOB AC AN     DP4 MQ\n2     NA -0.590765 0.166667  NA  NA  1  1 0,1,0,5 33\n                                                               Indiv gt_PL gt_GT gt_GT_alleles\n2 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 112,0     1             T\n</code></pre></p> <p>e. <pre><code>   sample_id      CHROM     POS ID      REF       ALT QUAL FILTER INDEL IDV IMF\n2 SRR2584863 CP000819.1  263235 NA        G         T   85     NA FALSE  NA  NA\n3 SRR2584863 CP000819.1  281923 NA        G         T  217     NA FALSE  NA  NA\n4 SRR2584863 CP000819.1  433359 NA CTTTTTTT CTTTTTTTT   64     NA  TRUE  12 1.0\n5 SRR2584863 CP000819.1  473901 NA     CCGC    CCGCGC  228     NA  TRUE   9 0.9\n6 SRR2584863 CP000819.1  648692 NA        C         T  210     NA FALSE  NA  NA\n7 SRR2584863 CP000819.1 1331794 NA        C         A  178     NA FALSE  NA  NA\n  DP      VDB RPB MQB BQB     MQSB       SGB     MQ0F ICB HOB AC AN     DP4 MQ\n2  6 0.096133   1   1   1       NA -0.590765 0.166667  NA  NA  1  1 0,1,0,5 33\n3 10 0.774083  NA  NA  NA 0.974597 -0.662043 0.000000  NA  NA  1  1 0,0,4,5 60\n4 12 0.477704  NA  NA  NA 1.000000 -0.676189 0.000000  NA  NA  1  1 0,1,3,8 60\n5 10 0.659505  NA  NA  NA 0.916482 -0.662043 0.000000  NA  NA  1  1 1,0,2,7 60\n6 10 0.268014  NA  NA  NA 0.916482 -0.670168 0.000000  NA  NA  1  1 0,0,7,3 60\n7  8 0.624078  NA  NA  NA 0.900802 -0.651104 0.000000  NA  NA  1  1 0,0,3,5 60\n                                                               Indiv gt_PL\n2 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 112,0\n3 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 247,0\n4 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam  91,0\n5 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 255,0\n6 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 240,0\n7 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 208,0\n  gt_GT gt_GT_alleles\n2     1             T\n3     1             T\n4     1     CTTTTTTTT\n5     1        CCGCGC\n6     1             T\n7     1             A\n</code></pre></p> <p>f.  <pre><code>[1] \"SRR2584863\" \"SRR2584863\" \"SRR2584863\" \"SRR2584863\"\n</code></pre></p> <p>g. <pre><code>                                REF\n1                                 T\n2                                 G\n3                                 G\n4                          CTTTTTTT\n5                              CCGC\n6                                 C\n7                                 C\n8                                 G\n9  ACAGCCAGCCAGCCAGCCAGCCAGCCAGCCAG\n10                               AT\n                                                        ALT\n1                                                         G\n2                                                         T\n3                                                         T\n4                                                 CTTTTTTTT\n5                                                    CCGCGC\n6                                                         T\n7                                                         A\n8                                                         A\n9  ACAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAG\n10                                                      ATT\n</code></pre></p> <p>h. <pre><code>[1] \"SRR2584863\" \"SRR2584863\" \"SRR2584863\" \"SRR2584863\" \"SRR2584863\"\n[6] \"SRR2584863\"\n</code></pre></p> <p>i. <pre><code>   sample_id      CHROM    POS ID      REF       ALT QUAL FILTER INDEL IDV IMF DP       VDB RPB\n1 SRR2584863 CP000819.1   9972 NA        T         G   91     NA FALSE  NA  NA  4 0.0257451  NA\n2 SRR2584863 CP000819.1 263235 NA        G         T   85     NA FALSE  NA  NA  6 0.0961330   1\n3 SRR2584863 CP000819.1 281923 NA        G         T  217     NA FALSE  NA  NA 10 0.7740830  NA\n4 SRR2584863 CP000819.1 433359 NA CTTTTTTT CTTTTTTTT   64     NA  TRUE  12 1.0 12 0.4777040  NA\n5 SRR2584863 CP000819.1 473901 NA     CCGC    CCGCGC  228     NA  TRUE   9 0.9 10 0.6595050  NA\n6 SRR2584863 CP000819.1 648692 NA        C         T  210     NA FALSE  NA  NA 10 0.2680140  NA\n  MQB BQB     MQSB       SGB     MQ0F ICB HOB AC AN     DP4 MQ\n1  NA  NA       NA -0.556411 0.000000  NA  NA  1  1 0,0,0,4 60\n2   1   1       NA -0.590765 0.166667  NA  NA  1  1 0,1,0,5 33\n3  NA  NA 0.974597 -0.662043 0.000000  NA  NA  1  1 0,0,4,5 60\n4  NA  NA 1.000000 -0.676189 0.000000  NA  NA  1  1 0,1,3,8 60\n5  NA  NA 0.916482 -0.662043 0.000000  NA  NA  1  1 1,0,2,7 60\n6  NA  NA 0.916482 -0.670168 0.000000  NA  NA  1  1 0,0,7,3 60\n                                                               Indiv gt_PL gt_GT gt_GT_alleles\n1 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 121,0     1             G\n2 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 112,0     1             T\n3 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 247,0     1             T\n4 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam  91,0     1     CTTTTTTTT\n5 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 255,0     1        CCGCGC\n6 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 240,0     1             T\n</code></pre></p> <p>j. <pre><code>     sample_id      CHROM     POS ID REF ALT QUAL FILTER INDEL IDV IMF DP\n796 SRR2589044 CP000819.1 3444175 NA   G   T  184     NA FALSE  NA  NA  9\n797 SRR2589044 CP000819.1 3481820 NA   A   G  225     NA FALSE  NA  NA 12\n798 SRR2589044 CP000819.1 3893550 NA  AG AGG  101     NA  TRUE   4   1  4\n799 SRR2589044 CP000819.1 3901455 NA   A  AC   70     NA  TRUE   3   1  3\n800 SRR2589044 CP000819.1 4100183 NA   A   G  177     NA FALSE  NA  NA  8\n801 SRR2589044 CP000819.1 4431393 NA TGG   T  225     NA  TRUE  10   1 10\n          VDB RPB MQB BQB     MQSB       SGB MQ0F ICB HOB AC AN     DP4 MQ\n796 0.4714620  NA  NA  NA 0.992367 -0.651104    0  NA  NA  1  1 0,0,4,4 60\n797 0.8707240  NA  NA  NA 1.000000 -0.680642    0  NA  NA  1  1 0,0,4,8 60\n798 0.9182970  NA  NA  NA 1.000000 -0.556411    0  NA  NA  1  1 0,0,3,1 52\n799 0.0221621  NA  NA  NA       NA -0.511536    0  NA  NA  1  1 0,0,3,0 60\n800 0.9272700  NA  NA  NA 0.900802 -0.651104    0  NA  NA  1  1 0,0,3,5 60\n801 0.7488140  NA  NA  NA 1.007750 -0.670168    0  NA  NA  1  1 0,0,4,6 60\n                                                                 Indiv gt_PL\n796 /home/dcuser/dc_workshop/results/bam/SRR2589044.aligned.sorted.bam 214,0\n797 /home/dcuser/dc_workshop/results/bam/SRR2589044.aligned.sorted.bam 255,0\n798 /home/dcuser/dc_workshop/results/bam/SRR2589044.aligned.sorted.bam 131,0\n799 /home/dcuser/dc_workshop/results/bam/SRR2589044.aligned.sorted.bam 100,0\n800 /home/dcuser/dc_workshop/results/bam/SRR2589044.aligned.sorted.bam 207,0\n801 /home/dcuser/dc_workshop/results/bam/SRR2589044.aligned.sorted.bam 255,0\n    gt_GT gt_GT_alleles\n796     1             T\n797     1             G\n798     1           AGG\n799     1            AC\n800     1             G\n801     1             T\n</code></pre></p> <p>k. <pre><code>[1] \"SRR2584863\" \"SRR2584863\" \"SRR2584863\" \"SRR2584863\" \"SRR2584863\"\n[6] \"SRR2584863\"\n</code></pre></p> <p>l. <pre><code>    sample_id      CHROM     POS ID REF ALT QUAL FILTER INDEL IDV IMF DP\n11 SRR2584863 CP000819.1 2407766 NA   A   C  104     NA FALSE  NA  NA  9\n12 SRR2584863 CP000819.1 2446984 NA   A   C  225     NA FALSE  NA  NA 20\n14 SRR2584863 CP000819.1 2665639 NA   A   T  225     NA FALSE  NA  NA 19\n16 SRR2584863 CP000819.1 3339313 NA   A   C  211     NA FALSE  NA  NA 10\n18 SRR2584863 CP000819.1 3481820 NA   A   G  200     NA FALSE  NA  NA  9\n19 SRR2584863 CP000819.1 3488669 NA   A   C  225     NA FALSE  NA  NA 13\n         VDB      RPB      MQB      BQB     MQSB       SGB     MQ0F ICB HOB AC\n11 0.0230738 0.900802 0.150134 0.750668 0.500000 -0.590765 0.333333  NA  NA  1\n12 0.0714027       NA       NA       NA 1.000000 -0.689466 0.000000  NA  NA  1\n14 0.9960390       NA       NA       NA 1.000000 -0.690438 0.000000  NA  NA  1\n16 0.4059360       NA       NA       NA 1.007750 -0.670168 0.000000  NA  NA  1\n18 0.1070810       NA       NA       NA 0.974597 -0.662043 0.000000  NA  NA  1\n19 0.0162706       NA       NA       NA 1.000000 -0.680642 0.000000  NA  NA  1\n   AN      DP4 MQ\n11  1  3,0,3,2 25\n12  1 0,0,10,6 60\n14  1 0,0,12,5 60\n16  1  0,0,4,6 60\n18  1  0,0,4,5 60\n19  1  0,0,8,4 60\n                                                                Indiv gt_PL\n11 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 131,0\n12 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 255,0\n14 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 255,0\n16 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 241,0\n18 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 230,0\n19 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 255,0\n   gt_GT gt_GT_alleles\n11     1             C\n12     1             C\n14     1             T\n16     1             C\n18     1             G\n19     1             C\n</code></pre></p> <p>The subsetting notation is very similar to what we learned for vectors. The key differences include:</p> <ul> <li>Typically provide two values separated by commas: <code>data.frame[row,      column]</code></li> <li>In cases where you are taking a continuous range of numbers use a     colon between the numbers (start:stop, inclusive)</li> <li>For a non continuous set of numbers, pass a vector using <code>c()</code></li> <li>Index using the name of a column(s) by passing them as vectors using     <code>c()</code></li> </ul> <p>Finally, in all of the subsetting exercises above, we printed values to the screen. You can create a new data frame object by assigning them to a new object name:</p> <p>r</p> <pre><code># Create a new data frame containing only observations from \"SRR2584863\"\nSRR2584863_variants &lt;- variants[variants$sample_id == \"SRR2584863\", ]\n\n# Check the dimension of the data frame\ndim(SRR2584863_variants)\n\n# Get a summary of the data frame\nsummary(SRR2584863_variants)\n</code></pre> Output <pre><code>[1] 25 29\n\n  sample_id            CHROM                POS             ID         \n Length:25          Length:25          Min.   :   9972   Mode:logical  \n Class :character   Class :character   1st Qu.:1331794   NA's:25       \n Mode  :character   Mode  :character   Median :2618472                 \n                                       Mean   :2464989                 \n                                       3rd Qu.:3488669                 \n                                       Max.   :4616538                 \n\n     REF                ALT                 QUAL         FILTER       \n Length:25          Length:25          Min.   : 31.89   Mode:logical  \n Class :character   Class :character   1st Qu.:104.00   NA's:25       \n Mode  :character   Mode  :character   Median :211.00                 \n                                       Mean   :172.97                 \n                                       3rd Qu.:225.00                 \n                                       Max.   :228.00                 \n\n   INDEL              IDV             IMF               DP      \n Mode :logical   Min.   : 2.00   Min.   :0.6667   Min.   : 2.0  \n FALSE:19        1st Qu.: 3.25   1st Qu.:0.9250   1st Qu.: 9.0  \n TRUE :6         Median : 8.00   Median :1.0000   Median :10.0  \n                 Mean   : 7.00   Mean   :0.9278   Mean   :10.4  \n                 3rd Qu.: 9.75   3rd Qu.:1.0000   3rd Qu.:12.0  \n                 Max.   :12.00   Max.   :1.0000   Max.   :20.0  \n                 NA's   :19      NA's   :19                     \n      VDB               RPB              MQB               BQB        \n Min.   :0.01627   Min.   :0.9008   Min.   :0.04979   Min.   :0.7507  \n 1st Qu.:0.07140   1st Qu.:0.9275   1st Qu.:0.09996   1st Qu.:0.7627  \n Median :0.37674   Median :0.9542   Median :0.15013   Median :0.7748  \n Mean   :0.40429   Mean   :0.9517   Mean   :0.39997   Mean   :0.8418  \n 3rd Qu.:0.65951   3rd Qu.:0.9771   3rd Qu.:0.57507   3rd Qu.:0.8874  \n Max.   :0.99604   Max.   :1.0000   Max.   :1.00000   Max.   :1.0000  \n                   NA's   :22       NA's   :22        NA's   :22      \n      MQSB             SGB               MQ0F           ICB         \n Min.   :0.5000   Min.   :-0.6904   Min.   :0.00000   Mode:logical  \n 1st Qu.:0.9599   1st Qu.:-0.6762   1st Qu.:0.00000   NA's:25       \n Median :0.9962   Median :-0.6620   Median :0.00000                 \n Mean   :0.9442   Mean   :-0.6341   Mean   :0.04667                 \n 3rd Qu.:1.0000   3rd Qu.:-0.6168   3rd Qu.:0.00000                 \n Max.   :1.0128   Max.   :-0.4536   Max.   :0.66667                 \n NA's   :3                                                          \n   HOB                AC          AN        DP4                  MQ       \n Mode:logical   Min.   :1   Min.   :1   Length:25          Min.   :10.00  \n NA's:25        1st Qu.:1   1st Qu.:1   Class :character   1st Qu.:60.00  \n                Median :1   Median :1   Mode  :character   Median :60.00  \n                Mean   :1   Mean   :1                      Mean   :55.52  \n                3rd Qu.:1   3rd Qu.:1                      3rd Qu.:60.00  \n                Max.   :1   Max.   :1                      Max.   :60.00  \n\n    Indiv              gt_PL               gt_GT   gt_GT_alleles     \n Length:25          Length:25          Min.   :1   Length:25         \n Class :character   Class :character   1st Qu.:1   Class :character  \n Mode  :character   Mode  :character   Median :1   Mode  :character  \n                                       Mean   :1                     \n                                       3rd Qu.:1                     \n                                       Max.   :1                     \n</code></pre>"},{"location":"03-basics-factors-dataframes/#introducing-factors","title":"Introducing factors","text":"<p>Factors are the final major data structure we will introduce in our Introduction  to R lessons. Factors can be thought of as vectors which are specialized for categorical data. Given R's specialization for statistics, this make sense since categorial and continuous variables are usually treated differently. Sometimes you may want to have data treated as a factor, but in other cases, this may be undesirable. Let's see the value of treating some of which are categorical in  nature as factors. Let's take a look at just the alternate alleles.</p> <p>r</p> <pre><code># Extract the \"ALT\" column to a new object\n\nalt_alleles &lt;- subset_variants$ALT\n</code></pre> <p>Let's look at the first few items in our factor using <code>head()</code>:</p> <p>r</p> <pre><code>head(alt_alleles)\n</code></pre> Output <pre><code>[1] \"G\"         \"T\"         \"T\"         \"CTTTTTTTT\" \"CCGCGC\"    \"T\"\n</code></pre> <p>There are 801 alleles (one for each row). To simplify, lets look at just the single-nucleotide alleles (SNPs). We can use some of the vector indexing skills from the last episode.</p> <p>r</p> <pre><code>alt_snps &lt;- c(alt_alleles[alt_alleles==\"A\"],\n              alt_alleles[alt_alleles==\"T\"],\n              alt_alleles[alt_alleles==\"G\"],\n              alt_alleles[alt_alleles==\"C\"])\n</code></pre> <p>This leaves us with a vector of the 701 alternative alleles which were single nucleotides. Right now, they are being treated a characters, but we could treat them as categories of SNP. Doing this will enable some nice features. For example, we can try to generate a plot of this character vector as it is right now:</p> <p>r</p> <pre><code>plot(alt_snps)\n</code></pre> Output <pre><code>Error in plot.window(...) : need finite 'ylim' values\nIn addition: Warning messages:\n1: In xy.coords(x, y, xlabel, ylabel, log) : NAs introduced by coercion\n2: In min(x) : no non-missing arguments to min; returning Inf\n3: In max(x) : no non-missing arguments to max; returning -Inf\n</code></pre> <p>Whoops! Though the <code>plot()</code> function will do its best to give us a quick plot, it is unable to do so here. One way to fix this it to tell R to treat the SNPs as categories (i.e.,\u00a0a factor vector); we will create a new object to avoid confusion using the <code>factor()</code> function:</p> <p>r</p> <pre><code>factor_snps &lt;- factor(alt_snps)\n</code></pre> <p>Let's learn a little more about this new type of vector:</p> <p>r</p> <pre><code>str(factor_snps)\n</code></pre> Output <pre><code> Factor w/ 4 levels \"A\",\"C\",\"G\",\"T\": 1 1 1 1 1 1 1 1 1 1 ...\n</code></pre> <p>What we get back are the categories (\"A\",\"C\",\"G\",\"T\") in our factor; these are called \"levels\". Levels are the different categories contained in a factor. By default, R will organize the levels in a factor in alphabetical order. So the first level in this factor is \"A\".</p> <p>For the sake of efficiency, R stores the content of a factor as a vector of integers, which an integer is assigned to each of the possible levels. Recall levels are assigned in alphabetical order. In this case, the first item in our <code>factor_snps</code> object is \"A\", which happens to be the 1<sup>st</sup> level of our factor, ordered alphabetically. This explains the sequence of \"1\"s (<code>Factor w/ 4 levels\"A\",\"C\",\"G\",\"T\": 1 1 1 1 1 1 1 1 1 1 ...</code>), since \"A\" is the first level and the first few items in our factor are all \"A\"s.</p> <p>We can see how many items in our vector fall into each category:</p> <p>r</p> <pre><code>summary(factor_snps)\n</code></pre> Output <pre><code>  A   C   G   T \n211 139 154 203\n</code></pre> <p>As you can imagine, this is already useful when you want to generate a tally.</p> <p>Treating objects as categories without changing their mode</p> <p>You don't have to make an object a factor to get the benefits of treating an object as a factor. See what happens when you use the <code>as.factor()</code> function on <code>factor_snps</code>. To generate a tally, you can sometimes also use the <code>table()</code> function; though sometimes you may need to combine both (i.e., <code>table(as.factor(object))</code>)</p>"},{"location":"03-basics-factors-dataframes/#plotting-and-ordering-factors","title":"Plotting and ordering factors","text":"<p>One of the most common uses for factors will be when you plot categorical values. For example, suppose we want to know how many of our variants had each possible SNP we could generate a plot:</p> <p>r</p> <pre><code>plot(factor_snps)\n</code></pre> Output <p></p> <p>This isn't a particularly pretty example of a plot but it works. We'll be learning much more about creating nice, publication-quality graphics later in this workshop.</p> <p>If you recall, factors are ordered alphabetically. That might make sense, but categories (e.g., \"red\", \"blue\", \"green\") often do not have an intrinsic order. What if we wanted to order our plot according to the numerical value (i.e., in descending order of SNP frequency)? We can enforce an order on our factors:</p> <p>r</p> <pre><code>ordered_factor_snps &lt;- factor(\n  factor_snps, \n  levels = names(sort(table(factor_snps)))\n)\n</code></pre> <p>Let's deconstruct this from the inside out (you can try each of these commands to see why this works):</p> <ol> <li>We create a table of <code>factor_snps</code> to get the frequency of each SNP:     <code>table(factor_snps)</code></li> <li>We sort this table: <code>sort(table(factor_snps))</code>; use the     <code>decreasing =</code> parameter for this function if you wanted to change     from the default of FALSE</li> <li>Using the <code>names()</code> function gives us just the character names of the     table sorted by frequencies:<code>names(sort(table(factor_snps)))</code></li> <li>The <code>factor</code> function is what allows us to create a factor. We give     it the <code>factor_snps</code> object as input, and use the <code>levels=</code>     parameter to enforce the ordering of the levels.</li> </ol> <p>Now we see our plot has be reordered:</p> <p>r</p> <pre><code>plot(ordered_factor_snps)\n</code></pre> Output <p></p> <p>Factors come in handy in many places when using R. Even using more sophisticated plotting packages such as <code>ggplot2</code> will sometimes require you to understand how to manipulate factors.</p> <p>Packages in R \u2013 what are they and why do we use them?</p> <p>Packages are simply collections of functions and/or data that can be used to extend the capabilities of R beyond the core functionality that comes with it by default. There are useful R packages available that span all types of statistical analysis, data visualization, and more. The main place that R packages are installed from is a website called CRAN (the Comprehensive R Archive Network). Many thousands of R packages are available there, and when you use the built-in R function <code>install.packages()</code>, it will look for a CRAN repository to install from. So, for example, to install tidyverse packages such as <code>dplyr</code> and <code>ggplot2</code> (which you'll do in the next few lessons), you would use the following command:</p> <p>r</p> <pre><code># Install a package from CRAN\ninstall.packages(\"ggplot2\")\n</code></pre>"},{"location":"03-basics-factors-dataframes/#coercing-values","title":"Coercing values","text":"<p>Sometimes, it is possible that R will misinterpret the type of data represented in a data frame, or store that data in a mode which prevents you from operating on the data the way you wish. For example, a long list of gene names isn't usually thought of as a categorical variable, the way that your experimental condition (e.g., control, treatment) might be. More importantly, some R packages you use to analyze your data may expect characters as input, not factors. At other times (such as plotting or some statistical analyses) a factor may be more appropriate. Ultimately, you should know how to change the mode of an object.</p> <p>First, its very important to recognize that coercion happens in R all the time. This can be a good thing when R gets it right, or a bad thing when the result is not what you expect. Consider:</p> <p>r</p> <pre><code>snp_chromosomes &lt;- c('3', '11', 'X', '6')\ntypeof(snp_chromosomes)\n</code></pre> Output <pre><code>[1] \"character\"\n</code></pre> <p>Although there are several numbers in our vector, they are all in quotes, so we have explicitly told R to consider them as characters. However, even if we removed the quotes from the numbers, R would coerce everything into a character:</p> <p>r</p> <pre><code>snp_chromosomes_2 &lt;- c(3, 11, 'X', 6)\ntypeof(snp_chromosomes_2)\nsnp_chromosomes_2[1]\n</code></pre> Output <pre><code>[1] \"character\"\n[1] \"3\"\n</code></pre> <p>We can use the <code>as.</code> functions to explicitly coerce values from one form into another. Consider the following vector of characters, which all happen to be valid numbers:</p> <p>r</p> <pre><code>snp_positions_2 &lt;- c(\"8762685\", \"66560624\", \"67545785\", \"154039662\")\ntypeof(snp_positions_2)\nsnp_positions_2[1]\n</code></pre> Output <pre><code>[1] \"character\"\n[1] \"8762685\"\n</code></pre> <p>Now we can coerce <code>snp_positions_2</code> into a numeric mode using <code>as.numeric()</code>:</p> <p>r</p> <pre><code>snp_positions_2 &lt;- as.numeric(snp_positions_2)\ntypeof(snp_positions_2)\nsnp_positions_2[1]\n</code></pre> Output <pre><code>[1] \"double\"\n[1] 8762685\n</code></pre> <p>Sometimes coercion is straight forward, but what would happen if we tried using <code>as.numeric()</code> on <code>snp_chromosomes_2</code></p> <p>r</p> <pre><code>snp_chromosomes_2 &lt;- as.numeric(snp_chromosomes_2)\n</code></pre> Output <pre><code>Warning message:\nNAs introduced by coercion\n</code></pre> <p>If we check, we will see that an <code>NA</code> value (R's default value for missing data) has been introduced.</p> <p>r</p> <pre><code>snp_chromosomes_2\n</code></pre> Output <pre><code>[1]  3 11 NA  6\n</code></pre> <p>Trouble can really start when we try to coerce a factor. For example, when we try to coerce the <code>factor_snps</code> into a numeric mode look at the  result: </p> <p>r</p> <pre><code>as.numeric(factor_snps)\n</code></pre> Output <pre><code>  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n [28] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n [55] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n [82] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n[109] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n[136] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n[163] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n[190] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 4 4 4 4 4\n[217] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\n[244] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\n[271] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\n[298] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\n[325] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\n[352] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\n[379] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4\n[406] 4 4 4 4 4 4 4 4 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n[433] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n[460] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n[487] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n[514] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n[541] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n[568] 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n[595] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n[622] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n[649] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n[676] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n[703] 2 2 2 2 2 \n</code></pre> <p>Strangely, it works! Almost. Instead of giving an error message, R returns numeric values, which in this case are the integers assigned to the levels in this factor. This kind of behavior can lead to hard-to-find bugs, for example when we do have numbers in a factor, and we get numbers from a coercion. If we don't look carefully, we may not notice a problem.</p> <p>If you need to coerce an entire column you can overwrite it using an expression like this one:</p> <p>r</p> <pre><code># Make the 'sample_id' column a factor type column\nvariants$sample_id &lt;- as.factor(variants$sample_id)\n\n# check the structure of the column\nstr(variants$sample_id)\n</code></pre> Output <pre><code>Factor w/ 3 levels \"SRR2584863\",\"SRR2584866\",..: 1 1 1 1 1 1 1 1 1 1 ...\n</code></pre>"},{"location":"03-basics-factors-dataframes/#lesson-summary-data-coercion","title":"Lesson summary: Data coercion","text":"<p>Lets summarize this section on coercion with a few take home messages.</p> <ul> <li>When you explicitly coerce one data type into another (this is known as   explicit coercion), be careful to check the result. Ideally, you should    try to see if its possible to avoid steps in your analysis that force you to   coerce.</li> <li>R will sometimes coerce without you asking for it. This is called   (appropriately) implicit coercion. For example when we tried to create   a vector with multiple data types, R chose one type through implicit   coercion.</li> <li>Check the structure (<code>str()</code>) of your data before working with them!</li> </ul> <p><code>StringsAsFactors</code></p> <p>Prior to R 4.0 when importing a data frame using any one of the <code>read.table()</code> functions such as <code>read.csv()</code> , the argument <code>StringsAsFactors</code> was by default set to true TRUE. Setting it to FALSE will treat any non-numeric column to a character type. <code>read.csv()</code> documentation, you will also see you can explicitly type your columns using the <code>colClasses</code> argument. Other R packages (such as the Tidyverse <code>readr</code>) don't have this particular conversion issue, but many packages will still try to guess a data type.</p>"},{"location":"03-basics-factors-dataframes/#data-frame-bonus-material-math-sorting-renaming","title":"Data frame bonus material: math, sorting, renaming","text":"<p>Here are a few operations that don't need much explanation, but which are good to know.</p> <p>There are lots of arithmetic functions you may want to apply to your data frame, covering those would be a course in itself (there is some starting material here).</p> <p>You can use functions like <code>mean()</code>, <code>min()</code>, <code>max()</code> on an individual column. Let's look at the \"DP\" or filtered depth. This value shows  the number of filtered reads that support each of the reported variants.</p> <p>r</p> <pre><code>max(variants$DP)\n</code></pre> Output <pre><code>[1] 79\n</code></pre> <p>You can sort a data frame using the <code>order()</code> function:</p> <p>r</p> <pre><code>sorted_by_DP &lt;- variants[order(variants$DP), ] \nhead(sorted_by_DP$DP)\n</code></pre> Output <pre><code>[1] 2 2 2 2 2 2\n</code></pre> <p>Exercise</p> <p>The <code>order()</code> function lists values in increasing order by default. Look at the documentation for this function and change <code>sorted_by_DP</code> to start with variants with the greatest filtered depth (\"DP\").</p> Solution <pre><code>sorted_by_DP &lt;- variants[order(variants$DP, decreasing = TRUE), ]\nhead(sorted_by_DP$DP)\n</code></pre> <p>Output</p> <pre><code>[1] 79 46 41 29 29 27\n</code></pre> <p>These functions work on vectors too!</p> <p>When using these functions (i.e., <code>mean()</code>, <code>min()</code>, <code>max()</code>, and <code>order()</code>), replace the input with a vector and it will do the same job! For example:</p> <p>r</p> <pre><code># Minimum position of a SNP\nmin(snp_positions)\n\n# Decreasing order of SNPs by positions\nsnp_positions[order(snp_positions, decreasing = TRUE)]\n</code></pre> <p>Output</p> <pre><code>[1] 8762685\n[1] 154039662  67545785  66560624   8762685\n</code></pre> <p>You can rename columns by logical subsetting or index:</p> <p>r</p> <pre><code># By logical subsetting\ncolnames(variants)[colnames(variants) == \"sample_id\"] &lt;- \"strain\"\n\n# By index\ncolnames(variants)[2] &lt;- \"chromosome\"\n\n# Check the column name (hint names are returned as a vector)\ncolnames(variants)\n</code></pre> Output <pre><code> [1] \"sample_id\"     \"CHROM\"         \"POS\"          \n [4] \"ID\"            \"REF\"           \"ALT\"          \n [7] \"QUAL\"          \"FILTER\"        \"INDEL\"        \n[10] \"IDV\"           \"IMF\"           \"DP\"           \n[13] \"VDB\"           \"RPB\"           \"MQB\"          \n[16] \"BQB\"           \"MQSB\"          \"SGB\"          \n[19] \"MQ0F\"          \"ICB\"           \"HOB\"          \n[22] \"AC\"            \"AN\"            \"DP4\"          \n[25] \"MQ\"            \"Indiv\"         \"gt_PL\"        \n[28] \"gt_GT\"         \"gt_GT_alleles\"\n</code></pre>"},{"location":"03-basics-factors-dataframes/#saving-your-data-frame-to-a-file","title":"Saving your data frame to a file","text":"<p>We can save data to a file. We will save our <code>SRR2584863_variants</code> object to a <code>.csv</code> (comma-separated values) file using the <code>write.csv()</code> function:</p> <p>r</p> <pre><code>write.csv(SRR2584863_variants, file = \"SRR2584863_variants.csv\")\n</code></pre> <p>The <code>write.csv()</code> function has some additional arguments listed in the help, but at a minimum you need to tell it what data frame to write to file, and give a path to a file name in quotes (if you only provide a file name, the file will be written in the current working directory).</p>"},{"location":"03-basics-factors-dataframes/#importing-data-from-excel","title":"Importing data from Excel","text":"<p>Excel is one of the most common formats, so we need to discuss how to make these files play nicely with R. The simplest way to import data from Excel is to save your Excel file in <code>.csv</code> format. You can then import into R right away. Sometimes you may not be able to do this (imagine you have data in 300 Excel files, are you going to open and export all of them?).</p> <p>One common R package (a set of code with features you can download and add to your R installation) is the readxl  package which can open and import Excel files. Rather than addressing package installation this second (we'll discuss this soon!), we can take advantage of RStudio's import feature which integrates this package. </p> <p><code>readxl</code>-RStudio integration</p> <p>This feature is only available on RStudio version 1.0.44 or later.</p> <p>First, in the RStudio menu go to File, select Import Dataset, and choose From Excel... (notice there are several other options you can explore).</p> <p></p> <p>Next, under File/Url: click the Browse button and navigate to the Ecoli_metadata.xlsx file located at <code>/home/dcuser/dc_sample_data/R</code>. You should now see a preview of the data to be imported:</p> <p></p> <p>Notice that you have the option to change the data type of each variable by clicking arrow (drop-down menu) next to each column title. Under Import Options you may also rename the data, choose a different sheet to import, and choose how you will handle headers and skipped rows. Under Code Preview you can see the code that will be used to import this file. We could have written this code and imported the Excel file without the RStudio import function, but now you can choose your preference.</p> <p>In this exercise, we will leave the name of the data frame as Ecoli_metadata, and there are no other options we need to adjust. Click the Import button to import the data.</p> <p>Finally, let's check the first few lines of the <code>Ecoli_metadata</code> data frame:</p> <p>r</p> <pre><code>head(Ecoli_metadata)\n</code></pre> Output <pre><code># A tibble: 6 \u00d7 7\n  sample   generation clade   strain cit     run       genome_size\n  &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 REL606            0 NA      REL606 unknown NA               4.62\n2 REL1166A       2000 unknown REL606 unknown SRR098028        4.63\n3 ZDB409         5000 unknown REL606 unknown SRR098281        4.6 \n4 ZDB429        10000 UC      REL606 unknown SRR098282        4.59\n5 ZDB446        15000 UC      REL606 unknown SRR098283        4.66\n6 ZDB458        20000 (C1,C2) REL606 unknown SRR098284        4.63\n</code></pre> <p>The type of this object is tibble, a type of data frame we will talk more about in the <code>dplyr</code> section. If you needed a true  R data frame you could coerce with <code>as.data.frame()</code>.</p> <p>Exercise: Putting it all together - data frames</p> <p>Using the <code>Ecoli_metadata</code> data frame created above, answer the following questions</p> <p>A)  What are the dimensions (# rows, # columns) of the data frame?</p> <p>B)  What are categories are there in the <code>cit</code> column? hint: treat column as factor</p> <p>C)  How many of each of the <code>cit</code> categories are there?</p> <p>D)  What is the genome size for the 7<sup>th</sup> observation in this data set?</p> <p>E)  What is the median value of the variable <code>genome_size</code>?</p> <p>F)  Rename the column <code>sample</code> to <code>sample_id</code>.</p> <p>G)  Create a new column named <code>genome_size_bp</code> and set it equal to the genome_size multiplied by 1,000,000.</p> <p>H)  Save the edited <code>Ecoli_metadata</code> data frame as \"exercise_solution.csv\" in your current working directory.</p> Solution <p>A)</p> <p>r</p> <pre><code>dim(Ecoli_metadata)\n</code></pre> Output <pre><code>[1] 30  7\n</code></pre> <p>B)</p> <p>r</p> <pre><code>levels(as.factor(Ecoli_metadata$cit))\n</code></pre> Output <pre><code>[1] \"minus\"   \"plus\"    \"unknown\"\n</code></pre> <p>C)</p> <p>r</p> <pre><code>table(as.factor(Ecoli_metadata$cit))\n</code></pre> Output <pre><code>minus    plus unknown \n    9       9      12 \n</code></pre> <p>D)</p> <p>r</p> <pre><code>Ecoli_metadata[7, 7]\n</code></pre> Output <pre><code># A tibble: 1 \u00d7 1\n  genome_size\n        &lt;dbl&gt;\n1        4.62 \n</code></pre> <p>E)</p> <p>r</p> <pre><code>median(Ecoli_metadata$genome_size)\n</code></pre> Output <pre><code>[1] 4.625\n</code></pre> <p>F)</p> <p>r</p> <pre><code>colnames(Ecoli_metadata)[colnames(Ecoli_metadata) == \"sample\"] &lt;- \"sample_id\"\n\n# Check the column names\ncolnames(Ecoli_metadata)\n</code></pre> Output <pre><code>[1] \"sample_id\"   \"generation\"  \"clade\"       \"strain\"     \n[5] \"cit\"         \"run\"         \"genome_size\"\n</code></pre> <p>G)</p> <p>r</p> <pre><code>Ecoli_metadata$genome_size_bp &lt;- Ecoli_metadata$genome_size * 1000000\n\n# Check the first few rows\nhead(Ecoli_metadata)\n</code></pre> Output <pre><code># A tibble: 6 \u00d7 8\n  sample_id generation clade   strain cit     run       genome_size genome_size_bp\n  &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;          &lt;dbl&gt;\n1 REL606             0 NA      REL606 unknown NA               4.62        4620000\n2 REL1166A        2000 unknown REL606 unknown SRR098028        4.63        4630000\n3 ZDB409          5000 unknown REL606 unknown SRR098281        4.6         4600000\n4 ZDB429         10000 UC      REL606 unknown SRR098282        4.59        4590000\n5 ZDB446         15000 UC      REL606 unknown SRR098283        4.66        4660000\n6 ZDB458         20000 (C1,C2) REL606 unknown SRR098284        4.63        4630000\n</code></pre> <p>H)</p> <p>r</p> <pre><code>write.csv(Ecoli_metadata, file = \"exercise_solution.csv\")\n</code></pre> <p>Check the Files tab on the bottom-right panel to see if the file is  there.</p>"},{"location":"06-data-visualization/","title":"Data Visualization with ggplot2","text":"<p>Info</p> Key pointsObjectivesQuestions <ul> <li><code>ggplot2</code> is a powerful tool for high-quality plots</li> <li><code>ggplot2</code> provides a flexible and readable grammar to build plots</li> </ul> <ul> <li>Describe the role of data, aesthetics, and geoms in ggplot functions.</li> <li>Choose the correct aesthetics and alter the geom parameters for a   scatter plot, bar chart, density, or box plot.</li> <li>Layer multiple geometries in a single plot.</li> <li>Customize plot titles, themes, and fonts.</li> <li>Apply a facet to a plot.</li> <li>Apply additional <code>ggplot2</code>-compatible plotting libraries.</li> <li>Save a ggplot to a file.</li> <li>List several resources for getting help with ggplot.</li> <li>List several resources for creating informative scientific plots.</li> </ul> <ul> <li>What is ggplot2?</li> <li>What is mapping, and what is aesthetics?</li> <li>What is the process of creating a publication-quality plots with   ggplot in R?</li> </ul>"},{"location":"06-data-visualization/#introduction-to-ggplot2","title":"Introduction to <code>ggplot2</code>","text":"<p><code>ggplot2</code> is a plotting package that makes it simple to create complex plots  from data in a data frame. It provides a more programmatic interface for  specifying what variables to plot, how they are displayed, and general visual  properties. Therefore, we only need minimal changes if the underlying data  change or if we decide to change from a bar plot to a scatter plot. This helps  in creating publication-quality plots with minimal adjustments and tweaking.</p> <p>The gg in \"ggplot\" stands for \"Grammar of Graphics,\"  which is an elegant yet powerful way to describe the making of scientific plots. In short, the grammar of graphics breaks down every plot into a few components,  namely, a dataset, a set of geoms (or geometric objects; visual marks that  represent the data points), and a coordinate system. You can imagine this is a  grammar that gives unique names to each component appearing in a plot and  conveys specific information about data. With ggplot, graphics are built  step-by-step by adding new elements.</p> <p>The idea of mapping is crucial in ggplot. One familiar example is to  map the value of one variable in a dataset to \\(x\\) and the other to \\(y\\).  However, we often encounter datasets that include more than two variables.  In this case, ggplot allows you to map those other variables to visual  marks such as color and shape. Along with the mapped coordinates  \\(x\\) and \\(y\\), these visual marks constitute the aesthetics of the figure  (specified using <code>aes()</code>). One thing you may want to remember is the difference  between discrete and continuous variables. Some aesthetics,  such as the shape of dots, do not accept continuous variables.  If forced to do so, R will give an error. This is easy to understand;  we cannot create a continuum of shapes for a variable, unlike, say, color.</p> <p>Checking continuous/discrete variables</p> <p>When having doubts about whether a variable is continuous or  discrete,  a quick way to check is to use the <code>summary()</code>  function. Continuous variables have descriptive statistics  (e.g., max, min, mean) but not the discrete variables.</p> <p>Installing <code>ggplot</code> on your local machine</p> <p>Here, we do not need to install <code>ggplot</code> while working within  NeSI's RStudio. However, if you would like to work on  your own local R/RStudio, you can install this package (or any other  packages) like so:</p> <p>r</p> <pre><code>install.packages(\"ggplot2\")\n</code></pre> <p><code>ggplot2</code> belongs to the <code>tidyverse</code>  framework, a suite of packages that  can help you with data import and manipulation.</p>"},{"location":"06-data-visualization/#loading-ggplot2-and-the-dataset","title":"Loading <code>ggplot2</code> and the dataset","text":"<p>Let's start by loading the required <code>ggplot2</code> package and importing the dataset  we will be working with.</p> <p>r</p> <pre><code># Load the ggplot2 package\nlibrary(ggplot2)\n\n# Load the dataset (for a fresh start)\nvariants &lt;- read.csv(\"/home/shared/&lt;USERID&gt;/R4Genomics/combined_tidy_vcf.csv\")\n</code></pre> <p>Explore the structure (types of columns and number of rows) of the dataset  using <code>str()</code>.</p> <p>r</p> <pre><code>str(variants)\n</code></pre> Output <pre><code>'data.frame':   801 obs. of  29 variables:\n $ sample_id    : chr  \"SRR2584863\" \"SRR2584863\" \"SRR2584863\" \"SRR2584863\" ...\n $ CHROM        : chr  \"CP000819.1\" \"CP000819.1\" \"CP000819.1\" \"CP000819.1\" ...\n $ POS          : int  9972 263235 281923 433359 473901 648692 1331794 1733343 2103887 2333538 ...\n $ ID           : logi  NA NA NA NA NA NA ...\n $ REF          : chr  \"T\" \"G\" \"G\" \"CTTTTTTT\" ...\n $ ALT          : chr  \"G\" \"T\" \"T\" \"CTTTTTTTT\" ...\n $ QUAL         : num  91 85 217 64 228 210 178 225 56 167 ...\n $ FILTER       : logi  NA NA NA NA NA NA ...\n $ INDEL        : logi  FALSE FALSE FALSE TRUE TRUE FALSE ...\n $ IDV          : int  NA NA NA 12 9 NA NA NA 2 7 ...\n $ IMF          : num  NA NA NA 1 0.9 ...\n $ DP           : int  4 6 10 12 10 10 8 11 3 7 ...\n $ VDB          : num  0.0257 0.0961 0.7741 0.4777 0.6595 ...\n $ RPB          : num  NA 1 NA NA NA NA NA NA NA NA ...\n $ MQB          : num  NA 1 NA NA NA NA NA NA NA NA ...\n $ BQB          : num  NA 1 NA NA NA NA NA NA NA NA ...\n $ MQSB         : num  NA NA 0.975 1 0.916 ...\n $ SGB          : num  -0.556 -0.591 -0.662 -0.676 -0.662 ...\n $ MQ0F         : num  0 0.167 0 0 0 ...\n $ ICB          : logi  NA NA NA NA NA NA ...\n $ HOB          : logi  NA NA NA NA NA NA ...\n $ AC           : int  1 1 1 1 1 1 1 1 1 1 ...\n $ AN           : int  1 1 1 1 1 1 1 1 1 1 ...\n $ DP4          : chr  \"0,0,0,4\" \"0,1,0,5\" \"0,0,4,5\" \"0,1,3,8\" ...\n $ MQ           : int  60 33 60 60 60 60 60 60 60 60 ...\n $ Indiv        : chr  \"/home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam\" \"/home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam\" \"/home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam\" \"/home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam\" ...\n $ gt_PL        : chr  \"121,0\" \"112,0\" \"247,0\" \"91,0\" ...\n $ gt_GT        : int  1 1 1 1 1 1 1 1 1 1 ...\n $ gt_GT_alleles: chr  \"G\" \"T\" \"T\" \"CTTTTTTTT\" ...\n</code></pre> <p>Alternatively, we can display the first a few rows (vertically) of the table using <code>head()</code>:</p> <p>r</p> <pre><code>head(variants)\n</code></pre> Output <pre><code>   sample_id      CHROM    POS ID      REF       ALT QUAL FILTER INDEL IDV IMF DP       VDB RPB\n1 SRR2584863 CP000819.1   9972 NA        T         G   91     NA FALSE  NA  NA  4 0.0257451  NA\n2 SRR2584863 CP000819.1 263235 NA        G         T   85     NA FALSE  NA  NA  6 0.0961330   1\n3 SRR2584863 CP000819.1 281923 NA        G         T  217     NA FALSE  NA  NA 10 0.7740830  NA\n4 SRR2584863 CP000819.1 433359 NA CTTTTTTT CTTTTTTTT   64     NA  TRUE  12 1.0 12 0.4777040  NA\n5 SRR2584863 CP000819.1 473901 NA     CCGC    CCGCGC  228     NA  TRUE   9 0.9 10 0.6595050  NA\n6 SRR2584863 CP000819.1 648692 NA        C         T  210     NA FALSE  NA  NA 10 0.2680140  NA\n  MQB BQB     MQSB       SGB     MQ0F ICB HOB AC AN     DP4 MQ\n1  NA  NA       NA -0.556411 0.000000  NA  NA  1  1 0,0,0,4 60\n2   1   1       NA -0.590765 0.166667  NA  NA  1  1 0,1,0,5 33\n3  NA  NA 0.974597 -0.662043 0.000000  NA  NA  1  1 0,0,4,5 60\n4  NA  NA 1.000000 -0.676189 0.000000  NA  NA  1  1 0,1,3,8 60\n5  NA  NA 0.916482 -0.662043 0.000000  NA  NA  1  1 1,0,2,7 60\n6  NA  NA 0.916482 -0.670168 0.000000  NA  NA  1  1 0,0,7,3 60\n                                                               Indiv gt_PL gt_GT gt_GT_alleles\n1 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 121,0     1             G\n2 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 112,0     1             T\n3 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 247,0     1             T\n4 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam  91,0     1     CTTTTTTTT\n5 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 255,0     1        CCGCGC\n6 /home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam 240,0     1             T\n</code></pre> <p><code>ggplot2</code> functions like data in the long format, i.e., a column for  every dimension (variable), and a row for every observation. Well-structured  data will save you time when making figures with <code>ggplot2</code>.</p> <p><code>ggplot2</code> graphics are built step-by-step by adding new elements. Adding  layers in this fashion allows for extensive flexibility and customization of  plots, and more equally important the readability of the code.</p> <p>To build a ggplot, we will use the following basic template that can be used for  different types of plots:</p> <pre><code>ggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) + &lt;GEOM_FUNCTION&gt;()\n</code></pre> <ul> <li>Use the <code>ggplot()</code> function and bind the plot to a specific data     frame using the <code>data</code> argument</li> </ul> <p>r</p> <pre><code>ggplot(data = variants)\n</code></pre> <ul> <li>Define a mapping (using the aesthetic (<code>aes</code>) function), by     selecting the variables to be plotted and specifying how to present     them in the graph, e.g.,\u00a0as x and y positions or characteristics such     as size, shape, color, etc.</li> </ul> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP))\n</code></pre> <ul> <li>Add 'geoms' \u2013 graphical representations of the data in the plot     (points, lines, bars). <code>ggplot2</code> offers many different geoms; we     will use some common ones today, including:<ul> <li><code>geom_point()</code>     for scatter plots, dot plots, etc.</li> <li><code>geom_boxplot()</code>     for, well, boxplots!</li> <li><code>geom_line()</code>     for trend lines, time series, etc.</li> </ul> </li> </ul> <p>To add a geom to the plot use the <code>+</code> operator. Because we have two continuous variables, let's use <code>geom_point()</code> (i.e., a scatter plot) first:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP)) + \n  geom_point()\n</code></pre> <p>The <code>+</code> in the <code>ggplot2</code> package is particularly useful because it allows you to modify existing <code>ggplot</code> objects. This means you can easily set up plot templates and conveniently explore different types of plots, so the above plot can also be generated with code like this:</p> <p>r</p> <pre><code># Assign plot to a variable \ncoverage_plot &lt;- ggplot(data = variants, aes(x = POS, y = DP))\n\n# Draw the plot\ncoverage_plot + \n  geom_point()\n</code></pre> <p>Notes</p> <ul> <li>Anything you put in the    <code>ggplot()</code>    function can be seen by any geom layers that you add (i.e., these are    universal plot settings). This includes the x- and y-axis mapping you    set up in <code>aes()</code>.</li> <li>You can also specify mappings for a given geom independently of the    mappings defined globally in the    <code>ggplot()</code>    function.</li> <li>The <code>+</code> sign used to add new layers must be placed at the end of the line    containing the previous layer. If, instead, the <code>+</code> sign is added at the    beginning of the line containing the new layer, <code>ggplot2</code> will not add    the new layer and will return an error message.</li> </ul> <p>r</p> <pre><code># This is the correct syntax for adding layers\ncoverage_plot +\n  geom_point()\n\n# This will not add the new layer and will return an error message\ncoverage_plot\n  + geom_point()\n</code></pre>"},{"location":"06-data-visualization/#building-your-plots-iteratively","title":"Building your plots iteratively","text":"<p>Building plots with <code>ggplot2</code> is typically an iterative process. We start by defining the dataset we'll use, lay out the axes, and choose a geom:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP)) + \n  geom_point()\n</code></pre> <p>Then, we start modifying this plot to extract more information from it. For instance, we can add transparency (<code>alpha</code>) to avoid over-plotting:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP)) + \n  geom_point(alpha = 0.5)\n</code></pre> <p>We can also add colors for all the points:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP)) + \n  geom_point(alpha = 0.5, color = \"blue\")\n</code></pre> <p>Or to color each species in the plot differently, you could use a vector as an  input to the argument <code>color</code>. <code>ggplot2</code> will provide a different color  corresponding to different values in the vector. Here is an example where we  color with <code>sample_id</code>:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +\n  geom_point(alpha = 0.5)\n</code></pre> <p>Notice that we can change the geom layer and colors will be still determined by <code>sample_id</code></p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +\n  geom_line(alpha = 0.5)\n</code></pre> <p>To make our plot more readable, we can add axis labels:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"Base Pair Position\",\n       y = \"Read Depth (DP)\")\n</code></pre> <p>To add a main title to the plot, we use <code>ggtitle()</code>:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"Base Pair Position\",\n       y = \"Read Depth (DP)\") +\n  ggtitle(\"Read Depth vs. Position\")\n</code></pre> <p>Using <code>labs()</code> for plot labels</p> <p>We can also use  <code>labs()</code> to create/modify labels beyond <code>x</code> and <code>y</code>, such as title, subtitle, caption,  etc. For example:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"Base Pair Position\",\n       y = \"Read Depth (DP)\",\n       title = \"Read Depth vs. Position\")\n</code></pre> <p>Now the figure is complete, we can export and save it to a file. This can be achieved easily using <code>ggsave()</code>, which can write, by default, the most recent generated figure into different formats (e.g., <code>jpeg</code>, <code>png</code>, <code>pdf</code>) according to the file extension. So, for example, to create a pdf version of the above figure with a dimension of 6 \\(\\times\\) 4 inches:</p> <p>r</p> <pre><code>ggsave(\"depth.pdf\", width = 6, height = 4)\n</code></pre> <p>If we check the current working directory, there should be a newly created file called <code>depth.pdf</code> with the above plot.</p> <p>Saving a plot using different units and formats</p> Size unitsFile formats <p>By default, <code>ggsave()</code> measures lengths in inches. To change that, we  can use the <code>units =</code> arguments. This argument will take <code>in</code>, <code>cm</code>, <code>mm</code>, and <code>px</code>.</p> <p>The example above writes the plot to a PDF. We can also save it to other  formats such as <code>jpeg</code>, <code>tiff</code>, <code>bmp</code>, <code>png</code>, etc. by modifying the  suffix (i.e. file extension).</p> <p>Challenge</p> <p>Use what you just learned to create a scatter plot of mapping quality (<code>MQ</code>) over position (<code>POS</code>) with the samples showing in different colors. Make sure to give your plot relevant axis labels.</p> Output <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = MQ, color = sample_id)) +   \n  geom_point() +   \n  labs(x = \"Base Pair Position\",        \n       y = \"Mapping Quality (MQ)\")\n</code></pre> <p>To further customize the plot, we can change the default font format:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +   \n  geom_point(alpha = 0.5) +   \n  labs(x = \"Base Pair Position\",        \n       y = \"Read Depth (DP)\") +   \n  ggtitle(\"Read Depth vs. Position\") +   \n  theme(text = element_text(family = \"mono\"))\n</code></pre>"},{"location":"06-data-visualization/#faceting","title":"Faceting","text":"<p><code>ggplot2</code> has a special technique called faceting that allows the user to split one plot into multiple plots (panels) based on a factor (variable) included in the dataset. We will use it to split our mapping quality plot into three panels, one for each sample.</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = MQ, color = sample_id)) +  \n  geom_point() +  \n  labs(x = \"Base Pair Position\",       \n       y = \"Mapping Quality (MQ)\") +  \n  facet_grid(. ~ sample_id)\n</code></pre> <p>This looks okay, but it would be easier to read if the plot facets were stacked vertically rather than horizontally. The <code>facet_grid</code> geometry allows you to explicitly specify how you want your plots to be arranged via formula notation (<code>rows ~ columns</code>; the dot (<code>.</code>) indicates every other variable in the data i.e., no faceting on that side of the formula).</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = MQ, color = sample_id)) +  \n  geom_point() +  \n  labs(x = \"Base Pair Position\",       \n       y = \"Mapping Quality (MQ)\") +  \n  facet_grid(sample_id ~ .)\n</code></pre> <p>Usually plots with white background look more readable when printed. We can set the background to white using the function <code>theme_bw()</code>. Additionally, you can remove the grid:</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = MQ, color = sample_id)) +   \n  geom_point() +   \n  labs(x = \"Base Pair Position\",        \n       y = \"Mapping Quality (MQ)\") +   \n  facet_grid(sample_id ~ .) +   \n  theme_bw() +   \n  theme(panel.grid = element_blank())\n</code></pre> <p>Challenge</p> <p>Use what you just learned to create a scatter plot of PHRED scaled quality (<code>QUAL</code>) over position (<code>POS</code>) with the points colored and faceted  based on samples. Make sure to give your plot relevant axis labels.</p> Solution <p>r</p> <pre><code>ggplot(data = variants, aes(x = POS, y = QUAL, color = sample_id)) + \n  geom_point() + \n  labs(x = \"Base Pair Position\", \n       y = \"PHRED-sacled Quality (QUAL)\") + \n  facet_grid(sample_id ~ .)\n</code></pre>"},{"location":"06-data-visualization/#bar-charts","title":"Bar charts","text":"<p>We can create bar charts using the <code>geom_bar</code> geom. Let's make a bar chart showing the number of variants for each sample that are indels.</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = INDEL, fill = sample_id)) +   \n  geom_bar() +   \n  facet_grid(sample_id ~ .)\n</code></pre> <p>Challenge</p> <p>Since we already have the <code>sample_id</code> labels on the individual plot facets, we don\u2019t need the legend. Use the help file for geom_bar and any other online resources you want to use to remove the legend from the plot.</p> Solution <p>r</p> <pre><code>ggplot(data = variants, aes(x = INDEL, color = sample_id)) +\n  geom_bar(show.legend = F) +\n  facet_grid(sample_id ~ .)\n</code></pre> <p>Notice that we did not need to map a variable to <code>y</code> in the aesthetics. This is because <code>geom_bar()</code> recognises, by default, that it should be counting the  number of observations that are indels (<code>TRUE</code>) or not (<code>FALSE</code>). Take a look at the help page for <code>geom_bar()</code> to find out how this behaviour is controlled.</p>"},{"location":"06-data-visualization/#density","title":"Density","text":"<p>We can create density plots using the <code>geom_density</code> geom that shows the distribution of of a variable in the dataset. Let's plot the distribution of <code>DP</code></p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = DP)) +   \n  geom_density()\n</code></pre> <p>This plot tells us that the most of frequent <code>DP</code> (read depth) for the variants is about 10 reads.</p> <p>Challenge</p> <p>Use <code>geom_density()</code> to plot the distribution of DP with a different fill  for each sample. Use a white background for the plot.</p> Solution <p>r</p> <pre><code>ggplot(data = variants, aes(x = DP, fill = sample_id)) +\n  geom_density(alpha = 0.5) +\n  theme_bw()\n</code></pre>"},{"location":"06-data-visualization/#box-plot","title":"Box plot","text":"<p>A box plot helps us to visualise the spread of grouped data. Let's take a look at the spread of read depth in different samples and whether or not the spread looks different if it is an indel.</p> <p>r</p> <pre><code>ggplot(data = variants, aes(x = sample_id, y = DP, fill = INDEL)) +\n  geom_boxplot(alpha = 0.5) +\n  theme_bw()\n</code></pre>"},{"location":"06-data-visualization/#ggplot2-themes","title":"<code>ggplot2</code> themes","text":"<p>In addition to <code>theme_bw()</code>, which changes the plot background to white, <code>ggplot2</code> comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. <code>theme_minimal()</code> and <code>theme_light()</code> are popular, and <code>theme_void()</code> can be useful as a starting point to create a new hand-crafted theme.</p> <p>The ggthemes package provides a wide variety of options (including Microsoft Excel, old and new). The <code>ggplot2</code> extensions website provides a list of packages that extend the capabilities of <code>ggplot2</code>, including additional themes.</p> <p>Challenge</p> <p>With all of this information in hand, please take another five minutes to either improve one of the plots generated in this exercise or create a beautiful graph of your own. Use the RStudio <code>ggplot2</code> cheat sheet for inspiration. Here are some ideas:</p> <ul> <li>See if you can change the size or shape of the plotting symbol.</li> <li>Can you find a way to change the name of the legend? What about its labels?</li> <li>Try using a different color palette (see the Cookbook for R).</li> </ul>"},{"location":"06-data-visualization/#more-ggplot2-plots","title":"More <code>ggplot2</code> Plots","text":"<p><code>ggplot2</code> offers many more informative and beautiful plots (<code>geoms</code>) of interest for biologists (although not covered in this lesson) that are worth exploring, such as</p> <ul> <li><code>geom_tile()</code>,     for heatmaps</li> <li><code>geom_jitter()</code>,     for strip charts</li> <li><code>geom_violin()</code>,     for violin plots</li> </ul> <p>Resources</p> <ul> <li>ggplot2: Elegant Graphics for Data Analysis (online version)</li> <li>The Grammar of Graphics (Statistics and Computing)</li> <li>Data Visualization: A Practical Introduction (online version)</li> <li>The R Graph Gallery (the book)</li> </ul>"},{"location":"07-knitr-markdown/","title":"Producing Reports With knitr","text":"<p>Info</p> Key pointsObjectivesQuestions <ul> <li>Keep reporting and R software together in one document using R   Markdown.</li> <li>Control formatting using chunk options.</li> <li><code>knitr</code> can convert R Markdown documents to PDF and other formats.</li> </ul> <ul> <li>Value of reproducible reports</li> <li>Basics of Markdown</li> <li>R code chunks</li> <li>Chunk options</li> <li>Inline R code</li> <li>Other output formats</li> <li>Simple Examples</li> </ul> <ul> <li>How can I integrate analyses and reports?</li> </ul>"},{"location":"07-knitr-markdown/#data-analysis-reports","title":"Data analysis reports","text":"<p>Data analysts tend to write a lot of reports, describing their analyses and results, for their collaborators or to document their work for future reference.</p> <p>When I was first starting out, I'd write an R script with all of my work, and would just send an email to my collaborator, describing the results and attaching various graphs. In discussing the results, there would often be confusion about which graph was which.</p> <p>I moved to writing formal reports, with Word or LaTeX, but I'd have to spend a lot of time getting the figures to look right. Mostly, the concern is about page breaks.</p> <p>Everything is easier now that I create a web page (as an html file). It can be one long stream, so I can use tall figures that wouldn't ordinary fit on one page. Scrolling is your friend.</p>"},{"location":"07-knitr-markdown/#literate-programming","title":"Literate programming","text":"<p>Ideally, such analysis reports are reproducible documents: If an error is discovered, or if some additional subjects are added to the data, you can just re-compile the report and get the new or corrected results (versus having to reconstruct figures, paste them into a Word document, and further hand-edit various detailed results).</p> <p>The key tool for R is <code>knitr</code>, which allows you to create a document that is a mixture of text and some chunks of code. When the document is processed by <code>knitr</code>, chunks of R code will be executed, and graphs or other results inserted.</p> <p>This sort of idea has been called \"literate programming\".</p> <p><code>knitr</code> allows you to mix basically any sort of text with any sort of code, but we recommend that you use R Markdown, which mixes Markdown with R. Markdown is a light-weight mark-up language for creating web pages.</p>"},{"location":"07-knitr-markdown/#creating-an-r-markdown-file","title":"Creating an R Markdown file","text":"<p>Within R Studio, click File \u2192 New File \u2192 R Markdown and you'll get a dialog box like this:</p> <p></p> <p>You can stick with the default (HTML output), but give it a title.</p>"},{"location":"07-knitr-markdown/#basic-components-of-r-markdown","title":"Basic components of R Markdown","text":"<p>The initial chunk of text contains instructions for R: you give the thing a title, author, and date, and tell it that you're going to want to produce html output (in other words, a web page).</p> <pre><code>---\ntitle: \"Initial R Markdown document\"\nauthor: \"Karl Broman\"\ndate: \"April 23, 2015\"\noutput: html_document\n---\n</code></pre> <p>You can delete any of those fields if you don't want them included. The double-quotes aren't strictly necessary in this case. They're mostly needed if you want to include a colon in the title.</p> <p>RStudio creates the document with some example text to get you started. Note below that there are chunks like</p> <pre>\n```{r}\nsummary(cars)\n```\n</pre> <p>These are chunks of R code that will be executed by knitr and replaced by their results. More on this later.</p> <p>Also note the web address that's put between angle brackets (<code>&lt; &gt;</code>) as well as the double-asterisks in <code>**Knit**</code>. This is Markdown.</p>"},{"location":"07-knitr-markdown/#markdown","title":"Markdown","text":"<p>Markdown is a system for writing web pages by marking up the text much as you would in an email rather than writing html code. The marked-up text gets converted to html, replacing the marks with the proper html code.</p> <p>For now, let's delete all of the stuff that's there and write a bit of markdown.</p> <p>You make things bold using two asterisks, like this: <code>**bold**</code>, and you make things italics by using underscores, like this: <code>_italics_</code>.</p> <p>You can make a bulleted list by writing a list with hyphens or asterisks, like this:</p> <pre><code>* bold with double-asterisks\n* italics with underscores\n* code-type font with backticks\n</code></pre> <p>or like this:</p> <pre><code>- bold with double-asterisks\n- italics with underscores\n- code-type font with backticks\n</code></pre> <p>Each will appear as:</p> <ul> <li>bold with double-asterisks</li> <li>italics with underscores</li> <li>code-type font with backticks</li> </ul> <p>(I prefer hyphens over asterisks, myself.)</p> <p>You can make a numbered list by just using numbers. You can use the same number over and over if you want:</p> <pre><code>1. bold with double-asterisks\n1. italics with underscores\n1. code-type font with backticks\n</code></pre> <p>This will appear as:</p> <ol> <li>bold with double-asterisks</li> <li>italics with underscores</li> <li>code-type font with backticks</li> </ol> <p>You can make section headers of different sizes by initiating a line with some number of <code>#</code> symbols:</p> <pre><code># Title\n## Main section\n### Sub-section\n#### Sub-sub section\n</code></pre> <p>You compile the R Markdown document to an html webpage by clicking the \"Knit HTML\" in the upper-left. And note the little question mark next to it; click the question mark and you'll get a \"Markdown Quick Reference\" (with the Markdown syntax) as well to the RStudio documentation on R Markdown.</p> <p>Challenge</p> <p>Create a new R Markdown document. Delete all of the R code chunks and write a bit of Markdown (some sections, some italicized text, and an itemized list).</p> <p>Convert the document to a webpage.</p>"},{"location":"07-knitr-markdown/#a-bit-more-markdown","title":"A bit more Markdown","text":"<p>You can make a hyperlink like this: <code>[text to show](http://the-web-page.com)</code>.</p> <p>You can include an image file like this: <code>![caption](http://url/for/file)</code></p> <p>You can do subscripts (e.g., F<sub>2</sub>) with <code>F~2~</code> and superscripts (e.g., F<sup>2</sup>) with <code>F^2^</code>.</p> <p>If you know how to write equations in LaTeX, you'll be glad to know that you can use <code>$ $</code> and <code>$$ $$</code> to insert math equations, like <code>$E = mc^2$</code> and</p> <pre><code>$$y = \\mu + \\sum_{i=1}^p \\beta_i x_i + \\epsilon$$\n</code></pre>"},{"location":"07-knitr-markdown/#r-code-chunks","title":"R code chunks","text":"<p>Markdown is interesting and useful, but the real power comes from mixing markdown with chunks of R code. This is R Markdown. When processed, the R code will be executed; if they produce figures, the figures will be inserted in the final document.</p> <p>The main code chunks look like this:</p> <pre>\n```{r load_data}\nvariants &lt;- read.csv(\"combined_tidy_vcf.csv\")\n```\n</pre> <p>That is, you place a chunk of R code between <code>```{r chunk_name}</code> and <code>```</code>. It's a good idea to give each chunk a name, as they will help you to fix errors and, if any graphs are produced, the file names are based on the name of the code chunk that produced them.</p> <p>Challenge</p> <p>Add code chunks to</p> <ul> <li>Load the <code>ggplot2</code> package</li> <li>Read the <code>variants</code> data</li> <li>Create a plot</li> </ul>"},{"location":"07-knitr-markdown/#how-things-get-compiled","title":"How things get compiled","text":"<p>When you press the \"Knit HTML\" button, the R Markdown document is processed by knitr and a plain Markdown document is produced (as well as, potentially, a set of figure files): the R code is executed and replaced by both the input and the output; if figures are produced, links to those figures are included.</p> <p>The Markdown and figure documents are then processed by the tool pandoc, which converts the Markdown file into an html file, with the figures embedded.</p> <p></p>"},{"location":"07-knitr-markdown/#chunk-options","title":"Chunk options","text":"<p>There are a variety of options to affect how the code chunks are treated.</p> <ul> <li>Use <code>echo = FALSE</code> to avoid having the code itself shown.</li> <li>Use <code>results = \"hide\"</code> to avoid having any results printed.</li> <li>Use <code>eval = FALSE</code> to have the code shown but not evaluated.</li> <li>Use <code>warning = FALSE</code> and <code>message = FALSE</code> to hide any warnings or     messages produced.</li> <li>Use <code>fig.height</code> and <code>fig.width</code> to control the size of the figures     produced (in inches).</li> </ul> <p>So you might write:</p> <pre>\n```{r load_libraries, echo=FALSE, message=FALSE}\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\n```\n</pre> <p>Often there will be particular options that you'll want to use repeatedly; for this, you can set global chunk options, like so:</p> <pre>\n```{r global_options, echo=FALSE}\nknitr::opts_chunk$set(fig.path=\"Figs/\", message=FALSE, warning=FALSE,\n                      echo=FALSE, results=\"hide\", fig.width=11)\n```\n</pre> <p>The <code>fig.path</code> option defines where the figures will be saved. The <code>/</code> here is really important; without it, the figures would be saved in the standard place but just with names that being with <code>Figs</code>.</p> <p>If you have multiple R Markdown files in a common directory, you might want to use <code>fig.path</code> to define separate prefixes for the figure file names, like <code>fig.path=\"Figs/cleaning-\"</code> and <code>fig.path=\"Figs/analysis-\"</code>.</p> <p>Challenge</p> <p>Use chunk options to control the size of a figure and to hide the code.</p>"},{"location":"07-knitr-markdown/#inline-r-code","title":"Inline R code","text":"<p>You can make every number in your report reproducible. Use <code>`r</code> and <code>`</code> for an in-line code chunk, like so: <code>`r nrow(variants)`</code>. The code will be executed and replaced with the value of the result.</p> <p>Lines</p> <p>Don't let these in-line chunks get split across lines.</p> <p>Perhaps precede the paragraph with a larger code chunk that does calculations and defines things, with <code>include=FALSE</code> for that larger chunk (which is the same as <code>echo=FALSE</code> and <code>results=\"hide\"</code>).</p> <p>Challenge</p> <p>Try out a bit of in-line R code.</p>"},{"location":"07-knitr-markdown/#other-output-options","title":"Other output options","text":"<p>You can also convert R Markdown to a PDF or a Word document. Click the little triangle next to the \"Knit HTML\" button to get a drop-down menu. Or you could put <code>pdf_document</code> or <code>word_document</code> in the header of the file.</p> <p>Creating PDF documents</p> <p>Creating .pdf documents may require installation of some extra software. If required this is detailed in an error message. To install the required software to knit your report to a PDF, you can run the following code:</p> <pre><code># these is already installed on NeSI\n# install.packages('tinytex')\n# tinytex::install_tinytex()\n</code></pre>"},{"location":"07-knitr-markdown/#simple-examples","title":"Simple Examples","text":"<p>Two simple examples of Markdowns with the data we have been using can be copied to your R4Genomics directory. Jump over to the Terminal tab, bottom left, beside Consol in your RStudio session. Note the use of the <code>*</code> as a wildcard, meaning the copy command will look for ALL <code>.Rmd</code> files in the directory. </p> <pre><code>cp /nesi/project/nesi02659/R4Genomics/*.Rmd ~/R4Genomics\n</code></pre> <p>You will then see them in your RStudio <code>Files</code> tab, click to open.</p> <p>Resources</p> <ul> <li>Knitr in a knutshell tutorial</li> <li>Dynamic Documents with R and      knitr      (book)</li> <li>R Markdown documentation</li> <li>R Markdown cheat      sheet      (PDF)</li> <li>Getting started with R      Markdown</li> <li>Reproducible      Reporting</li> <li>Introducing      Bookdown</li> </ul>"},{"location":"08-r-help/","title":"Getting help with R","text":"<p>Info</p> Key pointsObjectivesQuestions <ul> <li>R provides thousands of functions for analyzing data, and provides several way to get help</li> <li>Using R will mean searching for online help, and there are tips and resources on how to search effectively</li> </ul> <ul> <li>Locate help for an R function using <code>?</code>, <code>??</code>, and <code>args()</code></li> <li>Check the version of R</li> <li>Be able to ask effective questions when searching for help on forums or using web searches</li> </ul> <ul> <li>How do I get help using R and RStudio?</li> </ul>  ![oreilly_book_cover](figures/oreilly_book_covers.png){width=\"600\"}  <p>No matter how much experience you have with R, you will find yourself needing help. There is no shame in researching how to do something in R, and most people will find themselves looking up how to do the same things that they \"should know how to do\" over and over again. Here are some tips to make this process as helpful and efficient as possible.</p> <p>\"Never memorize something that you can look up\" \u2014 A. Einstein</p>"},{"location":"08-r-help/#finding-help-on-stackoverflow-and-biostars","title":"Finding help on Stackoverflow and Biostars","text":"<p>Two popular websites will be of great help with many R problems. For general R questions, Stack Overflow is probably the most popular online community for developers. If you start your question \"How to do X in R\" results from Stack Overflow are usually near the top of the list. For bioinformatics specific questions, Biostars is a popular online forum.</p> <p>Asking for help using online forums</p> <ul> <li>When searching for R help, look for answers with the r tag.</li> <li>Get an account; not required to view answers but to required to post</li> <li>Put in effort to check thoroughly before you post a question; folks get annoyed if you ask a very common question that has been answered multiple times</li> <li>Be careful. While forums are very helpful, you can't know for sure if the advice you are getting is correct</li> <li>See the How to ask for R help blog post for more useful tips</li> </ul>"},{"location":"08-r-help/#help-people-help-you","title":"Help people help you","text":"<p>Often, in order to duplicate the issue you are having, someone may need to see the data you are working with or verify the versions of R or R packages you are using. The following R functions will help with this:</p> <p>You can check the version of R (and any loaded packages) you are working  with using the <code>sessionInfo()</code> function. Actually, it is good to save this  information as part of your notes on any analysis you are doing. When you run  the same script that has worked fine a dozen times before, looking back at these notes will remind you that you upgraded R and forget to check your script.</p> <p>r</p> <pre><code>sessionInfo()\n</code></pre> <p>Output</p> <pre><code>R version 3.2.3 (2015-12-10)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 14.04.3 LTS\n\nlocale:\n[1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8\n[4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8\n[7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C\n[10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base\n\nloaded via a namespace (and not attached):\n[1] tools_3.2.3     packrat_0.4.9-1\n</code></pre> <p>Many times, there may be some issues with your data and the way it is formatted. In that case, you may want to share that data with someone else. However, you may not need to share the whole dataset; looking at a subset of your 50,000 row, 10,000 column data frame may be TMI (too much information)! You can take an object you have in memory such as a data frame and save it to a file. In our example we will use the <code>dput()</code>  function on the <code>iris</code> data frame which is an example dataset that is installed  in R:</p> <p>r</p> <pre><code>dput(head(iris)) \n\n# iris is an example data.frame that comes with R\n# the `head()` function just takes the first 6 lines of the iris dataset\n</code></pre> <p>This generates some output (below) which you will be better able to interpret after covering the other R lessons. This info would be helpful in understanding how the data is formatted and possibly revealing problematic issues.</p> <p>Output</p> <pre><code>structure(list(Sepal.Length = c(5.1, 4.9, 4.7, 4.6, 5, 5.4), \n    Sepal.Width = c(3.5, 3, 3.2, 3.1, 3.6, 3.9), Petal.Length = c(1.4, \n    1.4, 1.3, 1.5, 1.4, 1.7), Petal.Width = c(0.2, 0.2, 0.2, \n    0.2, 0.2, 0.4), Species = structure(c(1L, 1L, 1L, 1L, 1L, \n    1L), levels = c(\"setosa\", \"versicolor\", \"virginica\"), class = \"factor\")), row.names = c(NA, \n6L), class = \"data.frame\")\n</code></pre> <p>Alternatively, you can also save objects in R memory to a file by specifying the name of the object, in this case the <code>iris</code> data frame, and passing a filename to the <code>file=</code> argument.</p> <p>r</p> <pre><code>saveRDS(iris, file=\"iris.rds\") \n\n# By convention, we use the .rds file extension\n</code></pre>"},{"location":"08-r-help/#final-faqs-on-r","title":"Final FAQs on R","text":"<p>Finally, here are a few pieces of introductory R knowledge that are too good to pass up. While we won't return to them in this course, we put them here because they come up commonly:</p> <p>Do I need to click Run every time I want to run a script?</p> <ul> <li> <p>No.\u00a0In fact, the most common shortcut key allows you to run a     command (or any lines of the script that are highlighted):</p> <ul> <li>Windows execution shortcut:     Ctrl+Enter</li> <li>Mac execution shortcut:     Cmd(\u2318)+Enter</li> </ul> <p>To see a complete list of shortcuts, click on the Tools menu and select Keyboard Shortcuts Help</p> </li> </ul> <p>What's with the brackets in R console output?  - R returns an index with your result. When your result contains multiple values, the number tells you what ordinal number begins the line, for example:</p> <p>r</p> <pre><code>1:101 # generates the sequence of numbers from 1 to 101\n</code></pre> <p>Output</p> <pre><code>  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22\n [23]  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44\n [45]  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66\n [67]  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88\n [89]  89  90  91  92  93  94  95  96  97  98  99 100 101\n</code></pre> <p>In the output above, <code>[89]</code> indicates that the first value on that line is the 89<sup>th</sup> item in your result</p> <p>Can I run my R script without RStudio?</p> <ul> <li>Yes, remember - RStudio is running R. You get to use lots of the     enhancements RStudio provides, but R works independent of RStudio.     See these     tips     for running your commands at the command line</li> </ul> <p>Where else can I learn about RStudio?  - Check out the Help menu, especially \"Cheatsheets\" section</p>"},{"location":"appendix/04-bioconductor-vcfr/","title":"Using packages from Bioconductor","text":"<p>Info</p> Keyp ointsObjectivesQuestions <ul> <li>Bioconductor is an alternative package repository for bioinformatics packages.</li> <li>Installing packages from Bioconductor requires a new method, since it is not compatible with the <code>install.packages()</code> function used for CRAN.</li> <li>Check Bioconductor to see if there is a package relevant to your analysis before writing code yourself.</li> </ul> <ul> <li>Describe what the Bioconductor repository is and what it is used for</li> <li>Describe how Bioconductor differs from CRAN</li> <li>Search Bioconductor for relevant packages</li> <li>Install a package from Bioconductor</li> </ul> <ul> <li>How do I use packages from the Bioconductor repository?</li> </ul>"},{"location":"appendix/04-bioconductor-vcfr/#installing-packages-from-somewhere-else-besides-cran","title":"Installing packages from somewhere else besides CRAN?","text":"<p>So far we have told you about using packages that are included in the base installation of R (this is what comes with R 'out of the box'), and packages that you can install from CRAN (the Comprehensive R Archive Network), which is the primary place many people look for supplemental R packages to install. However, not all R packages are available on CRAN. For bioinformatics-related packages in particular, there is another repository that has many powerful packages that you can install. It is called Bioconductor and it is a repository specifically focused on bioinformatics packages. Bioconductor has a mission of \"promot[ing] the statistical analysis and comprehension of current and emerging high-throughput biological assays.\" This means that many if not all of the packages available on Bioconductor are focused on the analysis of biological data, and that it can be a great place to look for tools to help you analyze your -omics datasets!</p>"},{"location":"appendix/04-bioconductor-vcfr/#so-how-do-i-use-it","title":"So how do I use it?","text":"<p>Since access to the Bioconductor repository is not built in to base R 'out of the box', there are a couple steps needed to install packages from this alternative source. We will work through the steps (only 2!) to install a package to help with the VCF analysis we are working on, but you can use the same approach to install any of the many thousands of available packages.</p> <p></p>"},{"location":"appendix/04-bioconductor-vcfr/#first-install-the-biocmanager-package","title":"First, install the <code>BiocManager</code> package","text":"<p>The first step is to install a package that is on CRAN, <code>BiocManager</code>. This package will allow us to use it to install packages from Bioconductor. You can think of Bioconductor kind of like an alternative app store for your phone, except instead of apps you are installing packages, and instead of your phone it's your local R package library.</p> <p>r</p> <pre><code># Install the BiocManager from CRAN using the base R install.packages() function \ninstall.packages(\"BiocManager\")\n</code></pre> <p>To check if this worked (and also so you can make a note of the version for reproducibility purposes), you can run <code>BiocManager::version()</code> and it should give you the version number.</p>"},{"location":"appendix/04-bioconductor-vcfr/#second-install-the-vcfr-package-from-bioconductor-using-biocmanager","title":"Second, install the vcfR package from Bioconductor using <code>BiocManager</code>","text":"<p>Head's Up: Installing vcfR may take a while due to numerous dependencies</p> <p>Just be aware that installing packages that have many dependencies can take a while.</p> <p>r</p> <pre><code># install the vcfR package from Bioconductor \nBiocManager::install(\"vcfR\")\n</code></pre> <p>Depending on your particular system, you may need to also allow it to install some dependencies or update installed packages in order to successfully complete the process.</p> <p>Installing packages from Bioconductor vs from CRAN</p> <p>Some packages begin by being available only on Bioconductor, and then later move to CRAN. <code>vcfR</code> is one such package, which originally was only available from Bioconductor, but is currently available from CRAN. The other thing to know is that <code>BiocManager::install()</code> will also install packages from CRAN (it is a wrapper around <code>install.packages()</code> that adds some extra features). There are other benefits to using <code>BiocManager::install()</code> for Bioconductor packages, many of which are outlined here. In short, Bioconductor packages have a release cycle that is different from CRAN and the <code>install()</code> function is aware of that difference, so it helps to keep package versions in line with one another in a way that doesn't generally happen with the base R <code>install.packages()</code>.</p>"},{"location":"appendix/04-bioconductor-vcfr/#search-for-bioconductor-packages-based-on-your-analysis-needs","title":"Search for Bioconductor packages based on your analysis needs","text":"<p>While we are only focusing in this workshop on VCF analyses, there are hundreds or thousands of different types of data and analyses that bioinformaticians may want to work with. Sometimes you may get a new dataset and not know exactly where to start with analyzing or visualizing it. The Bioconductor package search view can be a great way to browse through the packages that are available.</p> <p></p> <p>Searching for packages on the Bioconductor website</p> <p>There are several thousand packages available through the Bioconductor website. It can be a bit of a challenge to find what you want, but one helpful resource is the package search page.</p> <p>In bioinformatics, there are often many different tools that can be used in a particular instance. The authors of <code>vcfR</code> have compiled some of them. One of those packages that is available from Bioconductor is called <code>VariantAnnotation</code> and may also be of interest to those working with vcf files in R.</p> <p>Challenge</p> <ul> <li>Use the <code>BiocManager::available()</code> function to see what packages are available matching a search term.</li> <li>Use the biocViews interface to search for packages of interest.</li> </ul> <p>You may or may not want to try installing the package, since not all dependencies always install easily. However, this will at least let you see what is available.</p> <p>Refreshing the RStudio package view after installing</p> <p>If you install a package from Bioconductor, you may need to refresh the RStudio package view to see it in your list. You can do this by clicking the Refresh button in Packages pane of RStudio.</p>"},{"location":"appendix/04-bioconductor-vcfr/#resources","title":"Resources","text":"<ul> <li>Bioconductor</li> <li>Bioconductor package     search</li> <li>CRAN</li> </ul>"},{"location":"appendix/05-dplyr/","title":"Data Wrangling and Analyses with Tidyverse","text":"<p>Info</p> Key pointsObjectivesQuestions <ul> <li>Use the <code>dplyr</code> package to manipulate data frames.</li> <li>Use <code>glimpse()</code> to quickly look at your data frame.</li> <li>Use <code>select()</code> to choose variables from a data frame.</li> <li>Use <code>filter()</code> to choose data based on values.</li> <li>Use <code>mutate()</code> to create new variables.</li> <li>Use <code>group_by()</code> and <code>summarize()</code> to work with subsets of data.</li> </ul> <ul> <li>Describe what the <code>dplyr</code> package in R is used for.</li> <li>Apply common <code>dplyr</code> functions to manipulate data in R.</li> <li>Employ the 'pipe' operator to link together a sequence of functions.</li> <li>Employ the 'mutate' function to apply other chosen functions to existing columns and create new columns of data.</li> <li>Employ the 'split-apply-combine' concept to split the data into groups, apply analysis to each group, and combine the results.</li> </ul> <ul> <li>How can I manipulate data frames without repeating myself?</li> </ul> <p>Bracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations.</p> <p>Luckily, the <code>dplyr</code> package provides a number of very useful functions for manipulating data frames in a way that will reduce repetition, reduce the probability of making errors, and probably even save you some typing. As an added bonus, you might even find the <code>dplyr</code> grammar easier to read.</p> <p>Here we're going to cover some of the most commonly used functions as well as using pipes (<code>%&gt;%</code>) to combine them:</p> <ol> <li><code>glimpse()</code></li> <li><code>select()</code></li> <li><code>filter()</code></li> <li><code>group_by()</code></li> <li><code>summarize()</code></li> <li><code>mutate()</code></li> <li><code>pivot_longer</code> and <code>pivot_wider</code></li> </ol> <p>Packages in R are sets of additional functions that let you do more stuff in R. The functions we've been using, like <code>str()</code>, come built into R; packages give you access to more functions. You need to install a package and then load it to be able to use it.</p> <p>r</p> <pre><code># Installs dplyr package \ninstall.packages(\"dplyr\") \n# Installs tidyr package \ninstall.packages(\"tidyr\") \n# Installs ggplot2 package \ninstall.packages(\"ggplot2\") \n# Install readr package`\ninstall.packages(\"readr\") \n</code></pre> <p>You might get asked to choose a CRAN mirror \u2014 this is asking you to choose a site to download the package from. The choice doesn't matter too much; I'd recommend choosing the RStudio mirror.</p> <p>r</p> <pre><code># Loads in dplyr package to use \nlibrary(\"dplyr\")          \n# Loads in tidyr package to use \nlibrary(\"tidyr\")          \n# Loads in ggplot2 package to use \nlibrary(\"ggplot2\")          \n# Load in readr package to use`\nlibrary(\"readr\")          \n</code></pre> <p>You only need to install a package once per computer, but you need to load it every time you open a new R session and want to use that package.</p> <p>Installing packages</p> <p>It may be temping to install the <code>tidyverse</code> package, as it contains many useful collection of packages for this lesson and beyond. However, when teaching or following this lesson, we advise that participants install <code>dplyr</code>, <code>readr</code>, <code>ggplot2</code>, and <code>tidyr</code> individually as shown above. Otherwise, a substantial amount of the lesson will be spent waiting for the installation to complete.</p>"},{"location":"appendix/05-dplyr/#what-is-dplyr","title":"What is dplyr?","text":"<p>The package <code>dplyr</code> tries to provide easy tools for the most common data  manipulation tasks. This package is also included in the <code>tidyverse</code>  package, which is a collection of eight different  packages (<code>dplyr</code>, <code>ggplot2</code>, <code>tibble</code>, <code>tidyr</code>, <code>readr</code>, <code>purrr</code>, <code>stringr</code>,  and <code>forcats</code>). It is built to work directly with data frames. The thinking  behind it was largely inspired by the package <code>plyr</code> which has been in use for  some time but suffered from being slow in some cases.<code>dplyr</code> addresses this by  porting much of the computation to C++. An additional feature is the ability to  work with data stored directly in an external database. The benefits of doing  this are that the data can be managed natively in a relational database, queries  can be conducted on that database, and only the results of the query returned.</p> <p>This addresses a common problem with R in that all operations are conducted in memory and thus the amount of data you can work with is limited by available memory. The database connections essentially remove that limitation in that you can have a database that is over 100s of GB, conduct queries on it directly and pull back just what you need for analysis in R.</p>"},{"location":"appendix/05-dplyr/#loading-csv-files-in-tidy-style","title":"Loading .csv files in tidy style","text":"<p>Tidyverse's <code>readr</code> package provides its own unique way of loading <code>.csv</code> files in to R using <code>read_csv()</code>, which is similar to <code>read.csv()</code>. <code>read_csv()</code> allows users to load in their data faster, doesn't create row names, and allows you to access non-standard variable names (ie. variables that start with numbers of contain spaces), and outputs your data on the R console in a tidier way. In short, it's a much friendlier way of loading in potentially messy data.</p> <p>Now let's load our vcf .csv file using <code>read_csv()</code>:</p> <p>r</p> <pre><code>variants &lt;- read_csv(\"combined_tidy_vcf.csv\")\n</code></pre> Output <pre><code>Rows: 801 Columns: 29\n\n\u2500\u2500 Column specification \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nDelimiter: \",\"\nchr  (7): sample_id, CHROM, REF, ALT, DP4, Indiv, gt_GT_alleles\ndbl (16): POS, QUAL, IDV, IMF, DP, VDB, RPB, MQB, BQB, MQSB, SGB, MQ0F, AC, AN, MQ, gt_GT\nnum  (1): gt_PL\nlgl  (5): ID, FILTER, INDEL, ICB, HOB\n\n\u2139 Use `spec()` to retrieve the full column specification for this data.\n\u2139 Specify the column types or set `show_col_types = FALSE` to quiet this message.\n</code></pre>"},{"location":"appendix/05-dplyr/#taking-a-quick-look-at-data-frames","title":"Taking a quick look at data frames","text":"<p>Similar to <code>str()</code>, which comes built into R, <code>glimpse()</code> is a <code>dplyr</code> function that (as the name suggests) gives a glimpse of the data frame.</p> <p>r</p> <pre><code>glimpse(variants)\n</code></pre> Output <pre><code>Rows: 801\nColumns: 29\n$ sample_id     &lt;chr&gt; \"SRR2584863\", \"SRR2584863\", \"SRR2584863\", \"SRR2584863\", \"SRR2584863\", \"S\u2026\n$ CHROM         &lt;chr&gt; \"CP000819.1\", \"CP000819.1\", \"CP000819.1\", \"CP000819.1\", \"CP000819.1\", \"C\u2026\n$ POS           &lt;dbl&gt; 9972, 263235, 281923, 433359, 473901, 648692, 1331794, 1733343, 2103887,\u2026\n$ ID            &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \u2026\n$ REF           &lt;chr&gt; \"T\", \"G\", \"G\", \"CTTTTTTT\", \"CCGC\", \"C\", \"C\", \"G\", \"ACAGCCAGCCAGCCAGCCAGC\u2026\n$ ALT           &lt;chr&gt; \"G\", \"T\", \"T\", \"CTTTTTTTT\", \"CCGCGC\", \"T\", \"A\", \"A\", \"ACAGCCAGCCAGCCAGCC\u2026\n$ QUAL          &lt;dbl&gt; 91.0000, 85.0000, 217.0000, 64.0000, 228.0000, 210.0000, 178.0000, 225.0\u2026\n$ FILTER        &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \u2026\n$ INDEL         &lt;lgl&gt; FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE,\u2026\n$ IDV           &lt;dbl&gt; NA, NA, NA, 12, 9, NA, NA, NA, 2, 7, NA, NA, NA, NA, NA, NA, NA, NA, NA,\u2026\n$ IMF           &lt;dbl&gt; NA, NA, NA, 1.000000, 0.900000, NA, NA, NA, 0.666667, 1.000000, NA, NA, \u2026\n$ DP            &lt;dbl&gt; 4, 6, 10, 12, 10, 10, 8, 11, 3, 7, 9, 20, 12, 19, 15, 10, 14, 9, 13, 2, \u2026\n$ VDB           &lt;dbl&gt; 0.0257451, 0.0961330, 0.7740830, 0.4777040, 0.6595050, 0.2680140, 0.6240\u2026\n$ RPB           &lt;dbl&gt; NA, 1.000000, NA, NA, NA, NA, NA, NA, NA, NA, 0.900802, NA, 0.954207, NA\u2026\n$ MQB           &lt;dbl&gt; NA, 1.0000000, NA, NA, NA, NA, NA, NA, NA, NA, 0.1501340, NA, 0.0497871,\u2026\n$ BQB           &lt;dbl&gt; NA, 1.000000, NA, NA, NA, NA, NA, NA, NA, NA, 0.750668, NA, 0.774755, NA\u2026\n$ MQSB          &lt;dbl&gt; NA, NA, 0.974597, 1.000000, 0.916482, 0.916482, 0.900802, 1.007750, 1.00\u2026\n$ SGB           &lt;dbl&gt; -0.556411, -0.590765, -0.662043, -0.676189, -0.662043, -0.670168, -0.651\u2026\n$ MQ0F          &lt;dbl&gt; 0.000000, 0.166667, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.\u2026\n$ ICB           &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \u2026\n$ HOB           &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \u2026\n$ AC            &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \u2026\n$ AN            &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \u2026\n$ DP4           &lt;chr&gt; \"0,0,0,4\", \"0,1,0,5\", \"0,0,4,5\", \"0,1,3,8\", \"1,0,2,7\", \"0,0,7,3\", \"0,0,3\u2026\n$ MQ            &lt;dbl&gt; 60, 33, 60, 60, 60, 60, 60, 60, 60, 60, 25, 60, 10, 60, 60, 60, 60, 60, \u2026\n$ Indiv         &lt;chr&gt; \"/home/dcuser/dc_workshop/results/bam/SRR2584863.aligned.sorted.bam\", \"/\u2026\n$ gt_PL         &lt;dbl&gt; 1210, 1120, 2470, 910, 2550, 2400, 2080, 2550, 11128, 1940, 1310, 2550, \u2026\n$ gt_GT         &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \u2026\n$ gt_GT_alleles &lt;chr&gt; \"G\", \"T\", \"T\", \"CTTTTTTTT\", \"CCGCGC\", \"T\", \"A\", \"A\", \"ACAGCCAGCCAGCCAGCC\u2026\n</code></pre> <p>In the above output, we can already gather some information about <code>variants</code>, such as the number of rows and columns, column names, type of vector in the columns, and the first few entries of each column. Although what we see is similar to outputs of <code>str()</code>, this method gives a cleaner visual output.</p>"},{"location":"appendix/05-dplyr/#selecting-columns-and-filtering-rows","title":"Selecting columns and filtering rows","text":"<p>To select columns of a data frame, use <code>select()</code>. The first argument to this function is the data frame (<code>variants</code>), and the subsequent arguments are the columns to keep.</p> <p>r</p> <pre><code>select(variants, sample_id, REF, ALT, DP)\n</code></pre> Output <pre><code># A tibble: 801 \u00d7 4\n   sample_id  REF                              ALT                                            DP\n   &lt;chr&gt;      &lt;chr&gt;                            &lt;chr&gt;                                       &lt;dbl&gt;\n 1 SRR2584863 T                                G                                               4\n 2 SRR2584863 G                                T                                               6\n 3 SRR2584863 G                                T                                              10\n 4 SRR2584863 CTTTTTTT                         CTTTTTTTT                                      12\n 5 SRR2584863 CCGC                             CCGCGC                                         10\n 6 SRR2584863 C                                T                                              10\n 7 SRR2584863 C                                A                                               8\n 8 SRR2584863 G                                A                                              11\n 9 SRR2584863 ACAGCCAGCCAGCCAGCCAGCCAGCCAGCCAG ACAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCC\u2026     3\n10 SRR2584863 AT                               ATT                                             7\n# \u2026 with 791 more rows\n# \u2139 Use `print(n = ...)` to see more rows\n</code></pre> <p>To select all columns except certain ones, put a \"-\" in front of the variable to exclude it.</p> <p>r</p> <pre><code>select(variants, -CHROM)\n</code></pre> Output <pre><code># A tibble: 801 \u00d7 28\n   sample_id      POS ID    REF   ALT    QUAL FILTER INDEL   IDV    IMF    DP    VDB   RPB   MQB\n   &lt;chr&gt;        &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;  &lt;lgl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 SRR2584863    9972 NA    T     G        91 NA     FALSE    NA NA         4 0.0257    NA    NA\n 2 SRR2584863  263235 NA    G     T        85 NA     FALSE    NA NA         6 0.0961     1     1\n 3 SRR2584863  281923 NA    G     T       217 NA     FALSE    NA NA        10 0.774     NA    NA\n 4 SRR2584863  433359 NA    CTTT\u2026 CTTT\u2026    64 NA     TRUE     12  1        12 0.478     NA    NA\n 5 SRR2584863  473901 NA    CCGC  CCGC\u2026   228 NA     TRUE      9  0.9      10 0.660     NA    NA\n 6 SRR2584863  648692 NA    C     T       210 NA     FALSE    NA NA        10 0.268     NA    NA\n 7 SRR2584863 1331794 NA    C     A       178 NA     FALSE    NA NA         8 0.624     NA    NA\n 8 SRR2584863 1733343 NA    G     A       225 NA     FALSE    NA NA        11 0.992     NA    NA\n 9 SRR2584863 2103887 NA    ACAG\u2026 ACAG\u2026    56 NA     TRUE      2  0.667     3 0.902     NA    NA\n10 SRR2584863 2333538 NA    AT    ATT     167 NA     TRUE      7  1         7 0.568     NA    NA\n# \u2026 with 791 more rows, and 14 more variables: BQB &lt;dbl&gt;, MQSB &lt;dbl&gt;, SGB &lt;dbl&gt;, MQ0F &lt;dbl&gt;,\n#   ICB &lt;lgl&gt;, HOB &lt;lgl&gt;, AC &lt;dbl&gt;, AN &lt;dbl&gt;, DP4 &lt;chr&gt;, MQ &lt;dbl&gt;, Indiv &lt;chr&gt;, gt_PL &lt;dbl&gt;,\n#   gt_GT &lt;dbl&gt;, gt_GT_alleles &lt;chr&gt;\n# \u2139 Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names\n</code></pre> <p><code>dplyr</code> also provides useful functions to select columns based on their names. For instance, <code>ends_with()</code> allows you to select columns that ends with specific letters. For instance, if you wanted to select columns that end with the letter \"B\":</p> <p>r</p> <pre><code>select(variants, ends_with(\"B\"))\n</code></pre> Output <pre><code># A tibble: 801 \u00d7 8\n      VDB   RPB   MQB   BQB   MQSB    SGB ICB   HOB  \n    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt;\n 1 0.0257    NA    NA    NA NA     -0.556 NA    NA   \n 2 0.0961     1     1     1 NA     -0.591 NA    NA   \n 3 0.774     NA    NA    NA  0.975 -0.662 NA    NA   \n 4 0.478     NA    NA    NA  1     -0.676 NA    NA   \n 5 0.660     NA    NA    NA  0.916 -0.662 NA    NA   \n 6 0.268     NA    NA    NA  0.916 -0.670 NA    NA   \n 7 0.624     NA    NA    NA  0.901 -0.651 NA    NA   \n 8 0.992     NA    NA    NA  1.01  -0.670 NA    NA   \n 9 0.902     NA    NA    NA  1     -0.454 NA    NA   \n10 0.568     NA    NA    NA  1.01  -0.617 NA    NA   \n# \u2026 with 791 more rows\n# \u2139 Use `print(n = ...)` to see more rows\n</code></pre> <p>Challenge</p> <p>Create a table that contains all the columns with the letter \"i\" and column \"POS\", without columns \"Indiv\" and \"FILTER\". Hint: look at for a function called <code>contains()</code>, which can be found in the help documentation for ends with we just covered (<code>?ends_with</code>). Note that contains() is not case sensistive.</p> Solution <p>r</p> <pre><code># First, we select \"POS\" and all columns with letter \"i\". This will contain columns     Indiv and FILTER. \nvariants_subset &lt;- select(variants, POS, contains(\"i\"))\n\n# Next, we remove columns Indiv and FILTER\nvariants_result &lt;- select(variants_subset, -Indiv, -FILTER)\nvariants_result\n</code></pre> Output <pre><code># A tibble: 801 \u00d7 7\n       POS sample_id  ID    INDEL   IDV    IMF ICB  \n     &lt;dbl&gt; &lt;chr&gt;      &lt;lgl&gt; &lt;lgl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt;\n 1    9972 SRR2584863 NA    FALSE    NA NA     NA   \n 2  263235 SRR2584863 NA    FALSE    NA NA     NA   \n 3  281923 SRR2584863 NA    FALSE    NA NA     NA   \n 4  433359 SRR2584863 NA    TRUE     12  1     NA   \n 5  473901 SRR2584863 NA    TRUE      9  0.9   NA   \n 6  648692 SRR2584863 NA    FALSE    NA NA     NA   \n 7 1331794 SRR2584863 NA    FALSE    NA NA     NA   \n 8 1733343 SRR2584863 NA    FALSE    NA NA     NA   \n 9 2103887 SRR2584863 NA    TRUE      2  0.667 NA   \n10 2333538 SRR2584863 NA    TRUE      7  1     NA   \n# \u2026 with 791 more rows\n# \u2139 Use `print(n = ...)` to see more rows\n</code></pre> Alternative solution <p>r</p> <pre><code>variants_result &lt;- select(variants, POS, contains(\"i\"), -Indiv, -FILTER)\n</code></pre> <p>To choose rows, use <code>filter()</code>:</p> <p>r</p> <pre><code>filter(variants, sample_id == \"SRR2584863\")\n</code></pre> Output <pre><code># A tibble: 25 \u00d7 29\n   sample_id  CHROM     POS ID    REF   ALT    QUAL FILTER INDEL   IDV    IMF    DP    VDB   RPB\n   &lt;chr&gt;      &lt;chr&gt;   &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;  &lt;lgl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n 1 SRR2584863 CP000\u2026 9.97e3 NA    T     G        91 NA     FALSE    NA NA         4 0.0257    NA\n 2 SRR2584863 CP000\u2026 2.63e5 NA    G     T        85 NA     FALSE    NA NA         6 0.0961     1\n 3 SRR2584863 CP000\u2026 2.82e5 NA    G     T       217 NA     FALSE    NA NA        10 0.774     NA\n 4 SRR2584863 CP000\u2026 4.33e5 NA    CTTT\u2026 CTTT\u2026    64 NA     TRUE     12  1        12 0.478     NA\n 5 SRR2584863 CP000\u2026 4.74e5 NA    CCGC  CCGC\u2026   228 NA     TRUE      9  0.9      10 0.660     NA\n 6 SRR2584863 CP000\u2026 6.49e5 NA    C     T       210 NA     FALSE    NA NA        10 0.268     NA\n 7 SRR2584863 CP000\u2026 1.33e6 NA    C     A       178 NA     FALSE    NA NA         8 0.624     NA\n 8 SRR2584863 CP000\u2026 1.73e6 NA    G     A       225 NA     FALSE    NA NA        11 0.992     NA\n 9 SRR2584863 CP000\u2026 2.10e6 NA    ACAG\u2026 ACAG\u2026    56 NA     TRUE      2  0.667     3 0.902     NA\n10 SRR2584863 CP000\u2026 2.33e6 NA    AT    ATT     167 NA     TRUE      7  1         7 0.568     NA\n# \u2026 with 15 more rows, and 15 more variables: MQB &lt;dbl&gt;, BQB &lt;dbl&gt;, MQSB &lt;dbl&gt;, SGB &lt;dbl&gt;,\n#   MQ0F &lt;dbl&gt;, ICB &lt;lgl&gt;, HOB &lt;lgl&gt;, AC &lt;dbl&gt;, AN &lt;dbl&gt;, DP4 &lt;chr&gt;, MQ &lt;dbl&gt;, Indiv &lt;chr&gt;,\n#   gt_PL &lt;dbl&gt;, gt_GT &lt;dbl&gt;, gt_GT_alleles &lt;chr&gt;\n# \u2139 Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names\n</code></pre> <p><code>filter()</code> will keep all the rows that match the conditions that are provided. Here are a few examples:</p> <p>r</p> <pre><code># Rows for which the reference genome has T or G\nfilter(variants, REF %in% c(\"T\", \"G\"))\n\n# Rows that have TRUE in the column INDEL\nfilter(variants, INDEL)\n\n# Rows that don't have missing data in the IDV column\nfilter(variants, !is.na(IDV))\n</code></pre> <p>We have a column titled \"QUAL\". This is a Phred-scaled confidence score that a polymorphism exists at this position given the sequencing data. Lower QUAL scores indicate low probability of a polymorphism existing at that site. <code>filter()</code> can be useful for selecting mutations that have a QUAL score above a certain threshold:</p> <p>r</p> <pre><code># Rows with QUAL values greater than or equal to 100\nfilter(variants, QUAL &gt;= 100)\n</code></pre> <p><code>filter()</code> allows you to combine multiple conditions. You can separate them using a <code>,</code> as arguments to the function, they will be combined using the <code>&amp;</code> (AND) logical operator. If you need to use the <code>|</code> (OR) logical operator, you can specify it explicitly:</p> <p>r</p> <pre><code># Using `,` as AND\nfilter(variants, sample_id == \"SRR2584863\", QUAL &gt;= 100)\n\n# Using `&amp;` as AND\nfilter(variants, sample_id == \"SRR2584863\" &amp; QUAL &gt;= 100)\n\n# Using `|` logical operator\nfilter(variants, sample_id == \"SRR2584863\", (MQ &gt;= 50 | QUAL &gt;= 100))\n</code></pre> <p>Challenge</p> <p>Select all the mutations that occurred between the positions 1e6 (one million) and 2e6 (inclusive) that have a QUAL greater than 200, and exclude INDEL mutations. Hint: to flip logical values such as TRUE to a FALSE, we can use to negation symbol <code>!</code>. (eg. <code>!TRUE == FALSE</code>).</p> Solution <p>r</p> <pre><code>filter(variants, POS &gt;= 1e6 &amp; POS &lt;= 2e6, QUAL &gt; 200, !INDEL)\n</code></pre> Output <pre><code># A tibble: 77 \u00d7 29\n   sampl\u2026\u00b9 CHROM    POS ID    REF   ALT    QUAL FILTER INDEL   IDV   IMF    DP   VDB   RPB   MQB\n   &lt;chr&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;  &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 SRR258\u2026 CP00\u2026 1.73e6 NA    G     A       225 NA     FALSE    NA    NA    11 0.992    NA    NA\n 2 SRR258\u2026 CP00\u2026 1.00e6 NA    A     G       225 NA     FALSE    NA    NA    15 0.481    NA    NA\n 3 SRR258\u2026 CP00\u2026 1.02e6 NA    A     G       225 NA     FALSE    NA    NA    12 0.242    NA    NA\n 4 SRR258\u2026 CP00\u2026 1.06e6 NA    C     T       225 NA     FALSE    NA    NA    17 0.346    NA    NA\n 5 SRR258\u2026 CP00\u2026 1.06e6 NA    A     G       206 NA     FALSE    NA    NA     9 0.630    NA    NA\n 6 SRR258\u2026 CP00\u2026 1.07e6 NA    G     T       225 NA     FALSE    NA    NA    11 0.349    NA    NA\n 7 SRR258\u2026 CP00\u2026 1.07e6 NA    T     C       225 NA     FALSE    NA    NA    12 0.196    NA    NA\n 8 SRR258\u2026 CP00\u2026 1.10e6 NA    C     T       225 NA     FALSE    NA    NA    15 0.454    NA    NAincluding\n 9 SRR258\u2026 CP00\u2026 1.11e6 NA    C     T       212 NA     FALSE    NA    NA     9 0.179    NA    NA\n10 SRR258\u2026 CP00\u2026 1.11e6 NA    A     G       225 NA     FALSE    NA    NA    14 0.909    NA    NA\n# \u2026 with 67 more rows, 14 more variables: BQB &lt;dbl&gt;, MQSB &lt;dbl&gt;, SGB &lt;dbl&gt;, MQ0F &lt;dbl&gt;,\n#   ICB &lt;lgl&gt;, HOB &lt;lgl&gt;, AC &lt;dbl&gt;, AN &lt;dbl&gt;, DP4 &lt;chr&gt;, MQ &lt;dbl&gt;, Indiv &lt;chr&gt;, gt_PL &lt;dbl&gt;,\n#   gt_GT &lt;dbl&gt;, gt_GT_alleles &lt;chr&gt;, and abbreviated variable name \u00b9\u200bsample_id\n# \u2139 Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names\n</code></pre>"},{"location":"appendix/05-dplyr/#pipes","title":"Pipes","text":"<p>But what if you wanted to select and filter? We can do this with pipes. Pipes  let you take the output of one function and send it directly to the next, which  is useful when you need to many things to the same data set. It was possible to  do this before pipes were added to R, but it was much messier and more  difficult. Pipes in R look like <code>%&gt;%</code> and are made available via the <code>magrittr</code>  package, which is installed as part of <code>dplyr</code>. If you use RStudio, you can type  the pipe with Ctrl + Shift + M if you're using  a PC, or Cmd + Shift + M if you're using a Mac.</p> <p>r</p> <pre><code>variants %&gt;%   \n  filter(sample_id == \"SRR2584863\") %&gt;%   \n  select(REF, ALT, DP)\n</code></pre> Output <pre><code># A tibble: 25 \u00d7 3\n   REF                              ALT                                                       DP\n   &lt;chr&gt;                            &lt;chr&gt;                                                  &lt;dbl&gt;\n 1 T                                G                                                          4\n 2 G                                T                                                          6\n 3 G                                T                                                         10\n 4 CTTTTTTT                         CTTTTTTTT                                                 12\n 5 CCGC                             CCGCGC                                                    10\n 6 C                                T                                                         10\n 7 C                                A                                                          8\n 8 G                                A                                                         11\n 9 ACAGCCAGCCAGCCAGCCAGCCAGCCAGCCAG ACAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGC\u2026     3\n10 AT                               ATT                                                        7\n# \u2026 with 15 more rows\n# \u2139 Use `print(n = ...)` to see more rows\n</code></pre> <p>In the above code, we use the pipe to send the <code>variants</code> data set first through <code>filter()</code>, to keep rows where <code>sample_id</code> matches a particular sample, and then through <code>select()</code> to keep only the <code>REF</code>, <code>ALT</code>, and <code>DP</code> columns. Since <code>%&gt;%</code> takes the object on its left and passes it as the first argument to the function on its right, we don't need to explicitly include the data frame as an argument to the <code>filter()</code> and <code>select()</code> functions any more.</p> <p>Some may find it helpful to read the pipe like the phrase \"then\". For instance, in the above example, we took the data frame <code>variants</code>, then we <code>filter()</code>ed for rows where <code>sample_id</code> was SRR2584863, then we <code>select()</code>ed the <code>REF</code>, <code>ALT</code>, and <code>DP</code> columns, then we showed only the first six rows. The <code>dplyr</code> functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex manipulations of data frames.</p> <p>If we want to create a new object with this smaller version of the data we can do so by assigning it a new name:</p> <p>r</p> <pre><code>SRR2584863_variants &lt;- variants %&gt;%   \n  filter(sample_id == \"SRR2584863\") %&gt;%   \n  select(REF, ALT, DP)\n</code></pre> <p>This new object includes all of the data from this sample. Let's look at just the first six rows to confirm it's what we want:</p> <p>r</p> <pre><code>SRR2584863_variants\n</code></pre> Output <pre><code># A tibble: 25 \u00d7 3\n   REF                              ALT                                                       DP\n   &lt;chr&gt;                            &lt;chr&gt;                                                  &lt;dbl&gt;\n 1 T                                G                                                          4\n 2 G                                T                                                          6\n 3 G                                T                                                         10\n 4 CTTTTTTT                         CTTTTTTTT                                                 12\n 5 CCGC                             CCGCGC                                                    10\n 6 C                                T                                                         10\n 7 C                                A                                                          8\n 8 G                                A                                                         11\n 9 ACAGCCAGCCAGCCAGCCAGCCAGCCAGCCAG ACAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGCCAGC\u2026     3\n10 AT                               ATT                                                        7\n# \u2026 with 15 more rows\n# \u2139 Use `print(n = ...)` to see more rows\n</code></pre> <p>Similar to <code>head()</code> and <code>tail()</code> functions, we can also look at the first or last six rows using tidyverse function <code>slice()</code>. Slice is a more versatile function that allows users to specify a range to view:</p> <p>r</p> <pre><code>SRR2584863_variants %&gt;% slice(1:6)\n</code></pre> Output <pre><code># A tibble: 6 \u00d7 3\n  REF      ALT          DP\n  &lt;chr&gt;    &lt;chr&gt;     &lt;dbl&gt;\n1 T        G             4\n2 G        T             6\n3 G        T            10\n4 CTTTTTTT CTTTTTTTT    12\n5 CCGC     CCGCGC       10\n6 C        T            10\n</code></pre> <p>r</p> <pre><code>SRR2584863_variants %&gt;% slice(10:25)\n</code></pre> Output <pre><code># A tibble: 16 \u00d7 3\n   REF   ALT      DP\n   &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n 1 AT    ATT       7\n 2 A     C         9\n 3 A     C        20\n 4 G     T        12\n 5 A     T        19\n 6 G     A        15\n 7 A     C        10\n 8 C     A        14\n 9 A     G         9\n10 A     C        13\n11 A     AC        2\n12 G     T        10\n13 A     G        16\n14 A     C        11\n15 TGG   T        10\n16 A     C         9\n</code></pre> <p>Exercise: Pipe and filter</p> <p>Starting with the <code>variants</code> data frame, use pipes to subset the data to include only observations from SRR2584863 sample, where the filtered depth (DP) is at least 10. Showing only 5<sup>th</sup> through 11<sup>th</sup> rows of columns <code>REF</code>, <code>ALT</code>, and <code>POS</code>.</p> Solution <p>r</p> <pre><code>variants %&gt;%\n  filter(sample_id == \"SRR2584863\" &amp; DP &gt;= 10) %&gt;%\n  slice(5:11) %&gt;%\n  select(sample_id, DP, REF, ALT, POS)\n</code></pre> Output <pre><code># A tibble: 7 \u00d7 5\n  sample_id     DP REF   ALT       POS\n  &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;\n1 SRR2584863    11 G     A     1733343\n2 SRR2584863    20 A     C     2446984\n3 SRR2584863    12 G     T     2618472\n4 SRR2584863    19 A     T     2665639\n5 SRR2584863    15 G     A     2999330\n6 SRR2584863    10 A     C     3339313\n7 SRR2584863    14 C     A     3401754\n</code></pre>"},{"location":"appendix/05-dplyr/#mutate","title":"Mutate","text":"<p>Frequently you'll want to create new columns based on the values in existing columns, for example to do unit conversions or find the ratio of values in two columns. For this we'll use the <code>dplyr</code> function <code>mutate()</code>.</p> <p>For example, we can convert the polymorphism confidence value QUAL to a probability value according to the formula:</p> \\[\\textrm {Probability} = 1- 10 ^ {-\\frac{\\textrm{QUAL}}{10}}\\] <p>We can use <code>mutate()</code> to add a column (<code>POLPROB</code>) to our <code>variants</code> data frame that shows the probability of a polymorphism at that site given the data.</p> <p>r</p> <pre><code>variants %&gt;%   \n  mutate(POLPROB = 1 - (10 ^ -(QUAL/10)))\n</code></pre> <p>Exercise</p> <p>There are a lot of columns in our data set, so let's just look at the <code>sample_id</code>, <code>POS</code>, <code>QUAL</code>, and <code>POLPROB</code> columns for now. Add a line to the above code to only show those columns.</p> Solution <p>r</p> <pre><code>variants %&gt;%   \n  mutate(POLPROB = 1 - (10 ^ -(QUAL/10))) %&gt;%\n  select(sample_id, POS, QUAL, POLPROB)\n</code></pre> Output <pre><code># A tibble: 801 \u00d7 4\n   sample_id      POS  QUAL POLPROB\n   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 SRR2584863    9972    91    1.00\n 2 SRR2584863  263235    85    1.00\n 3 SRR2584863  281923   217    1   \n 4 SRR2584863  433359    64    1.00\n 5 SRR2584863  473901   228    1   \n 6 SRR2584863  648692   210    1   \n 7 SRR2584863 1331794   178    1   \n 8 SRR2584863 1733343   225    1   \n 9 SRR2584863 2103887    56    1.00\n10 SRR2584863 2333538   167    1   \n# \u2026 with 791 more rows\n# \u2139 Use `print(n = ...)` to see more rows\n</code></pre>"},{"location":"appendix/05-dplyr/#group_by-and-summarize-functions","title":"<code>group_by()</code> and <code>summarize()</code> functions","text":"<p>Many data analysis tasks can be approached using the \"split-apply-combine\" paradigm: split the data into groups, apply some analysis to each group, and then combine the results. <code>dplyr</code> makes this very easy through the use of the <code>group_by()</code> function, which splits the data into groups.</p> <p>We can use <code>group_by()</code> to tally the number of mutations detected in each sample using the function <code>tally()</code>:</p> <p>r</p> <pre><code>variants %&gt;%   \n  group_by(sample_id) %&gt;%   \n  tally()\n</code></pre> Output <pre><code># A tibble: 3 \u00d7 2\n  sample_id      n\n  &lt;chr&gt;      &lt;int&gt;\n1 SRR2584863    25\n2 SRR2584866   766\n3 SRR2589044    10\n</code></pre> <p>Since counting or tallying values is a common use case for <code>group_by()</code>, an alternative function was created to bypasses <code>group_by()</code> using the function <code>count()</code>:</p> <p>r</p> <pre><code>variants %&gt;% \n  count(sample_id)\n</code></pre> <p>Challenge</p> <p>How many mutations are INDELs?</p> Solution <p>r</p> <pre><code>variants %&gt;%\n  count(INDEL)\n</code></pre> <p>Output</p> <pre><code># A tibble: 2 \u00d7 2\n  INDEL     n\n  &lt;lgl&gt; &lt;int&gt;\n1 FALSE   700\n2 TRUE    101\n</code></pre> <p>When the data is grouped, <code>summarize()</code> can be used to collapse each group into a single-row summary. <code>summarize()</code> does this by applying an aggregating or summary function to each group.</p> <p>It can be a bit tricky at first, but we can imagine physically splitting the data frame by groups and applying a certain function to summarize the data.</p> <p><sup>1</sup></p> <p>We can also apply many other functions to individual columns to get other summary statistics. For example, we can use built-in functions like <code>mean()</code>, <code>median()</code>, <code>min()</code>, and <code>max()</code>. These are called \"built-in functions\" because they come with R and don't require that you install any additional packages. By default, all R functions operating on vectors that contains missing data will return NA. It's a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. When dealing with simple statistics like the mean, the easiest way to ignore <code>NA</code> (the missing data) is to use <code>na.rm = TRUE</code> (<code>rm</code> stands for remove).</p> <p>So to view the mean, median, maximum, and minimum filtered depth (<code>DP</code>) for each sample:</p> <p>r</p> <pre><code>variants %&gt;%   \n  group_by(sample_id) %&gt;%   \n  summarize(     \n    mean_DP = mean(DP),     \n    median_DP = median(DP),     \n    min_DP = min(DP),     \n    max_DP = max(DP)\n  )\n</code></pre> Output <pre><code># A tibble: 3 \u00d7 5\n  sample_id  mean_DP median_DP min_DP max_DP\n  &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 SRR2584863    10.4      10        2     20\n2 SRR2584866    10.6      10        2     79\n3 SRR2589044     9.3       9.5      3     16\n</code></pre>"},{"location":"appendix/05-dplyr/#reshaping-data-frames","title":"Reshaping data frames","text":"<p>It can sometimes be useful to transform the \"long\" tidy format, into the wide format. This transformation can be done with the <code>pivot_wider()</code> function provided by the <code>tidyr</code> package (also part of the <code>tidyverse</code>).</p> <p><code>pivot_wider()</code> takes a data frame as the first argument, and two arguments: the column name that will become the columns and the column name that will become the cells in the wide data.</p> <p>r</p> <pre><code>variants_wide &lt;- variants %&gt;%\n  group_by(sample_id, CHROM) %&gt;%\n  summarize(mean_DP = mean(DP)) %&gt;%\n  pivot_wider(names_from = sample_id, values_from = mean_DP)\n\nvariants_wide\n</code></pre> Output <pre><code># A tibble: 1 \u00d7 4\n  CHROM      SRR2584863 SRR2584866 SRR2589044\n  &lt;chr&gt;           &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 CP000819.1       10.4       10.6        9.3\n</code></pre> <p>The opposite operation of <code>pivot_wider()</code> is taken care by <code>pivot_longer()</code>. We specify the names of the new columns, and here add <code>-CHROM</code> as this column shouldn't be affected by the reshaping:</p> <p>r</p> <pre><code>variants_wide %&gt;%\n  pivot_longer(-CHROM, names_to = \"sample_id\", values_to = \"mean_DP\")\n</code></pre> Output <pre><code># A tibble: 3 \u00d7 3\n  CHROM      sample_id  mean_DP\n  &lt;chr&gt;      &lt;chr&gt;        &lt;dbl&gt;\n1 CP000819.1 SRR2584863    10.4\n2 CP000819.1 SRR2584866    10.6\n3 CP000819.1 SRR2589044     9.3\n</code></pre>"},{"location":"appendix/05-dplyr/#resources","title":"Resources","text":"<ul> <li> <p>Handy dplyr     cheatsheet</p> </li> <li> <p>Much of this lesson was copied or adapted from Jeff Hollister's     materials</p> </li> </ul> <ol> <li> <p>The figure was adapted from the Software Carpentry lesson, R for Reproducible Scientific Analysis \u21a9</p> </li> </ol>"}]}